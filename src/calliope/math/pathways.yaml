constraints:
  flow_capacity_per_storage_capacity_min:
    foreach: [nodes, techs, carriers, investsteps]

  flow_capacity_per_storage_capacity_max:
    foreach: [nodes, techs, carriers, investsteps]

  source_capacity_equals_flow_capacity:
    foreach: [nodes, techs, carriers, investsteps]

  force_zero_area_use:
    foreach: [nodes, techs, investsteps]

  area_use_per_flow_capacity:
    foreach: [nodes, techs, carriers, investsteps]

  area_use_capacity_per_loc:
    foreach: [nodes, investsteps]

  flow_capacity_systemwide_max:
    foreach: [techs, carriers, investsteps]

  flow_capacity_systemwide_min:
    foreach: [techs, carriers, investsteps]

  balance_conversion:
    foreach: [nodes, techs, timesteps, investsteps]

  flow_out_max:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_out_min:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_in_max:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  source_max:
    foreach: [nodes, techs, timesteps, investsteps]

  storage_max:
    foreach: [nodes, techs, timesteps, investsteps]

  storage_discharge_depth_limit:
    foreach: [nodes, techs, timesteps, investsteps]

  system_balance:
    foreach: [nodes, carriers, timesteps, investsteps]

  balance_demand:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  balance_demand_min_use:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  balance_supply_no_storage:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  balance_supply_with_storage:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  source_availability_supply:
    foreach: [nodes, techs, timesteps, investsteps]

  balance_supply_min_use:
    foreach: [nodes, techs, timesteps, investsteps]

  balance_storage:
    foreach: [nodes, techs, timesteps, investsteps]

  set_storage_initial:
    foreach: [nodes, techs, investsteps]

  balance_transmission:
    foreach: [techs, timesteps, investsteps]

  symmetric_transmission:
    foreach: [nodes, techs, investsteps]

  export_balance:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_export_max:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  unit_commitment_milp:
    foreach: [nodes, techs, timesteps, investsteps]

  available_flow_cap_binary:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  available_flow_cap_continuous:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  available_flow_cap_max_binary_continuous_switch:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_out_max_milp:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_in_max_milp:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_out_min_milp:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  storage_capacity_units_milp:
    foreach: [nodes, techs, carriers, investsteps]

  flow_capacity_units_milp:
    foreach: [nodes, techs, carriers, investsteps]

  flow_capacity_max_purchase_milp:
    foreach: [nodes, techs, carriers, investsteps]

  flow_capacity_min_purchase_milp:
    foreach: [nodes, techs, carriers, investsteps]

  storage_capacity_max_purchase_milp:
    foreach: [nodes, techs, investsteps]

  storage_capacity_min_purchase_milp:
    foreach: [nodes, techs, investsteps]

  unit_capacity_max_systemwide_milp:
    foreach: [techs, investsteps]

  unit_capacity_min_systemwide_milp:
    foreach: [techs, investsteps]

  async_flow_in_milp:
    foreach: [nodes, techs, timesteps, investsteps]

  async_flow_out_milp:
    foreach: [nodes, techs, timesteps, investsteps]

  ramping_up:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  ramping_down:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_cap_bounding:
    description: >-
      Flow capacity in a given investment period is the capacity in the previous period
      plus the new capacity installed minus old capacity that has been decommissioned
      between the previous period and this one.
    foreach: [nodes, techs, carriers, investsteps]
    where: flow_cap
    equations:
      - expression: >-
          flow_cap == (
            $flow_cap_previous_step + flow_cap_new -
            default_if_empty(flow_cap_decommissioned, 0) -
            (flow_cap_initial * decommission_initial_cap)
          )
    sub_expressions:
      flow_cap_previous_step:
        - where: investsteps=get_val_at_index(investsteps=0)
          expression: flow_cap_initial
        - where: NOT investsteps=get_val_at_index(investsteps=0)
          expression: roll(flow_cap, investsteps=1)

  storage_cap_bounding:
    description: >-
      Storage capacity in a given investment period is the capacity in the previous period
      plus the new capacity installed minus old capacity that has been decommissioned
      between the previous period and this one.
    foreach: [nodes, techs, investsteps]
    where: storage_cap
    equations:
      - expression: >-
          storage_cap == (
            $storage_cap_previous_step + storage_cap_new -
            default_if_empty(storage_cap_decommissioned, 0) -
            (storage_cap_initial * decommission_initial_cap)
          )
    sub_expressions:
      storage_cap_previous_step:
        - where: investsteps=get_val_at_index(investsteps=0)
          expression: storage_cap_initial
        - where: NOT investsteps=get_val_at_index(investsteps=0)
          expression: roll(storage_cap, investsteps=1)

  source_cap_bounding:
    description: >-
      Storage capacity in a given investment period is the capacity in the previous period
      plus the new capacity installed minus old capacity that has been decommissioned
      between the previous period and this one.
    foreach: [nodes, techs, investsteps]
    where: source_cap
    equations:
      - expression: >-
          source_cap == (
            $source_cap_previous_step + source_cap_new -
            default_if_empty(source_cap_decommissioned, 0) -
            (source_cap_initial * decommission_initial_cap)
          )
    sub_expressions:
      source_cap_previous_step:
        - where: investsteps=get_val_at_index(investsteps=0)
          expression: source_cap_initial
        - where: NOT investsteps=get_val_at_index(investsteps=0)
          expression: roll(source_cap, investsteps=1)

  area_use_bounding:
    description: >-
      Area use in a given investment period is the area use in the previous period
      plus the new area used minus old used area that has been decommissioned
      between the previous period and this one.
    foreach: [nodes, techs, investsteps]
    where: area_use
    equations:
      - expression: >-
          area_use == (
            $area_use_previous_step + area_use_new -
            default_if_empty(area_use_decommissioned, 0) -
            (area_use_initial * decommission_initial_cap)
          )
    sub_expressions:
      area_use_previous_step:
        - where: investsteps=get_val_at_index(investsteps=0)
          expression: area_use_initial
        - where: NOT investsteps=get_val_at_index(investsteps=0)
          expression: roll(area_use, investsteps=1)

  cost_flow_cap_bounding:
    description: >-
      Flow cap investment is based on the amount paid in the last investment period
      plus the cost of new capacity minus the cost of capacity that is now decommissioned.
      This _should_ mean that capacity is linked to the investment cost when it was _commissioned_.
      TODO: this should probably be annualised now rather than waiting until later.
    foreach: [nodes, techs, carriers, costs, investsteps]
    where: cost_investment_flow_cap
    equations:
      - expression: >-
          cost_investment_flow_cap == $flow_cap_invest_previous_step
          + $cost_sum * flow_cap_new
          - get_decommission_cap($cost_sum * flow_cap_new)
    sub_expressions:
      flow_cap_invest_previous_step:
        - where: investsteps=get_val_at_index(investsteps=0)
          expression: "0"
        - where: NOT investsteps=get_val_at_index(investsteps=0)
          expression: roll(cost_investment_flow_cap, investsteps=1)
      cost_sum:
        - where: base_tech=transmission
          expression: (cost_flow_cap + cost_flow_cap_per_distance * default_if_empty(distance, 0)) * 0.5
        - where: NOT base_tech=transmission
          expression: cost_flow_cap

  cost_storage_cap_bounding:
    description: >-
      Storage cap investment is based on the amount paid in the last investment period
      plus the cost of new capacity minus the cost of capacity that is now decommissioned.
      This _should_ mean that capacity is linked to the investment cost when it was _commissioned_.
      TODO: this should probably be annualised now rather than waiting until later.
    foreach: [nodes, techs, costs, investsteps]
    where: cost_investment_storage_cap
    equations:
      - expression: >-
          cost_investment_storage_cap == $storage_cap_invest_previous_step
          + cost_storage_cap * storage_cap_new
          - get_decommission_cap(cost_storage_cap * storage_cap_new)
    sub_expressions:
      storage_cap_invest_previous_step:
        - where: investsteps=get_val_at_index(investsteps=0)
          expression: "0"
        - where: NOT investsteps=get_val_at_index(investsteps=0)
          expression: roll(cost_investment_storage_cap, investsteps=1)

  cost_source_cap_bounding:
    description: >-
      Source cap investment is based on the amount paid in the last investment period
      plus the cost of new capacity minus the cost of capacity that is now decommissioned.
      This _should_ mean that capacity is linked to the investment cost when it was _commissioned_.
      TODO: this should probably be annualised now rather than waiting until later.
    foreach: [nodes, techs, costs, investsteps]
    where: cost_investment_source_cap
    equations:
      - expression: >-
          cost_investment_source_cap == $source_cap_invest_previous_step
          + cost_source_cap * source_cap_new
          - get_decommission_cap(cost_source_cap * source_cap_new)
    sub_expressions:
      source_cap_invest_previous_step:
        - where: investsteps=get_val_at_index(investsteps=0)
          expression: "0"
        - where: NOT investsteps=get_val_at_index(investsteps=0)
          expression: roll(cost_investment_source_cap, investsteps=1)

  cost_area_use_bounding:
    description: >-
      Area use investment is based on the amount paid in the last investment period
      plus the cost of new area use minus the cost of area use that is now decommissioned.
      This _should_ mean that area use is linked to the investment cost when it was _commissioned_.
      TODO: this should probably be annualised now rather than waiting until later.
    foreach: [nodes, techs, costs, investsteps]
    where: cost_investment_area_use
    equations:
      - expression: >-
          cost_investment_area_use == $area_use_invest_previous_step
          + cost_area_use * area_use_new
          - get_decommission_cap(cost_area_use * area_use_new)
    sub_expressions:
      area_use_invest_previous_step:
        - where: investsteps=get_val_at_index(investsteps=0)
          expression: "0"
        - where: NOT investsteps=get_val_at_index(investsteps=0)
          expression: roll(cost_investment_area_use, investsteps=1)

  link_storage_level:
    description: Link the storage level at the end of one investmentstep to the start of the next.
    foreach: [nodes, techs, costs, investsteps]
    where: storage AND NOT investsteps=get_val_at_index(investsteps=0)
    equations:
      - expression: >-
          storage[timesteps=$initial_step] == roll(
            storage[timesteps=$final_step] * (
              (1 - storage_loss) ** timestep_resolution[timesteps=$final_step]
            ),
            investsteps=1
          )
    slices:
      initial_step:
        - expression: get_val_at_index(timesteps=0)
      final_step:
        - expression: get_val_at_index(timesteps=-1)

variables:
  flow_cap:
    foreach: [nodes, techs, carriers, investsteps]

  link_flow_cap:
    foreach: [techs, investsteps]

  flow_out:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_in:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_export:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  area_use:
    foreach: [nodes, techs, investsteps]

  source_use:
    foreach: [nodes, techs, timesteps, investsteps]

  source_cap:
    foreach: [nodes, techs, investsteps]

  storage_cap:
    foreach: [nodes, techs, investsteps]

  storage:
    foreach: [nodes, techs, timesteps, investsteps]

  purchased_units:
    foreach: [nodes, techs, investsteps]

  operating_units:
    foreach: [nodes, techs, timesteps, investsteps]

  available_flow_cap:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  async_flow_switch:
    foreach: [nodes, techs, timesteps, investsteps]

  unmet_demand:
    foreach: [nodes, carriers, timesteps, investsteps]

  unused_supply:
    foreach: [nodes, carriers, timesteps, investsteps]

  flow_cap_new:
    description: >-
      Additional flow capacity commissioned in an investstep.
    unit: power
    where: flow_cap
    foreach: [nodes, techs, carriers, investsteps]
    bounds:
      min: 0
      max: flow_cap_max

  storage_cap_new:
    description: >-
      Additional storage capacity commissioned in an investstep.
    unit: energy
    where: storage_cap
    foreach: [nodes, techs, investsteps]
    bounds:
      min: 0
      max: storage_cap_max

  source_cap_new:
    description: >-
      Additional source capacity commissioned in an investstep.
    unit: power
    where: source_cap
    foreach: [nodes, techs, investsteps]
    bounds:
      min: 0
      max: source_cap_max

  area_use_new:
    description: >-
      Additional area use commissioned in an investstep.
    unit: area
    where: area_use
    foreach: [nodes, techs, investsteps]
    bounds:
      min: 0
      max: area_use_max

  cost_investment_flow_cap:
    foreach: [nodes, techs, carriers, costs, investsteps]
    unit: cost
    where: flow_cap
    bounds:
      min: -.inf
      max: .inf

  cost_investment_storage_cap:
    foreach: [nodes, techs, costs, investsteps]
    unit: cost
    where: storage_cap
    bounds:
      min: -.inf
      max: .inf

  cost_investment_source_cap:
    foreach: [nodes, techs, costs, investsteps]
    unit: cost
    where: source_cap
    bounds:
      min: -.inf
      max: .inf

  cost_investment_area_use:
    foreach: [nodes, techs, costs, investsteps]
    unit: cost
    where: area_use
    bounds:
      min: -.inf
      max: .inf

global_expressions:
  flow_out_inc_eff:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  flow_in_inc_eff:
    foreach: [nodes, techs, carriers, timesteps, investsteps]

  cost_var:
    foreach: [nodes, techs, costs, timesteps, investsteps]

  # these are now decision variables
  # so they can refer to themselves recursively in a constraint.
  cost_investment_flow_cap:
    active: false

  cost_investment_storage_cap:
    active: false

  cost_investment_source_cap:
    active: false

  cost_investment_area_use:
    active: false

  cost_investment_purchase:
    foreach: [nodes, techs, costs, investsteps]

  cost_investment:
    foreach: [nodes, techs, costs, investsteps]

  cost:
    foreach: [nodes, techs, costs, investsteps]

  flow_cap_decommissioned:
    foreach: [nodes, techs, carriers, investsteps]
    where: flow_cap_new AND lifetime
    equations:
      - expression: get_decommission_cap(flow_cap_new)

  storage_cap_decommissioned:
    foreach: [nodes, techs, investsteps]
    where: storage_cap_new AND lifetime
    equations:
      - expression: get_decommission_cap(storage_cap_new)

  source_cap_decommissioned:
    foreach: [nodes, techs, investsteps]
    where: source_cap_new AND lifetime
    equations:
      - expression: get_decommission_cap(source_cap_new)

  area_use_decommissioned:
    foreach: [nodes, techs, investsteps]
    where: area_use_new AND lifetime
    equations:
      - expression: get_decommission_cap(area_use_new)



objectives:
  min_cost_optimisation:
    equations:
      - where: "any(cost, over=[nodes, techs, costs, investsteps])"
        expression: >-
          sum(
            sum(
              sum(cost, over=[nodes, techs])
              * investstep_resolution,
              over=investsteps
            )
            * objective_cost_weights,
            over=costs
          ) + $unmet_demand
      - where: "NOT any(cost, over=[nodes, techs, costs, investsteps])"
        expression: $unmet_demand
    sub_expressions:
      unmet_demand:
        - where: "config.ensure_feasibility=True"
          expression: >-
            sum(
              sum(
                sum(unmet_demand - unused_supply, over=[carriers, nodes]) * timestep_weights,
                over=timesteps
              )
              * investstep_resolution,
              over=investsteps
            ) * bigM
        - where: "NOT config.ensure_feasibility=True"
          expression: "0"