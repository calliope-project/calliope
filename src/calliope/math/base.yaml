constraints:
  flow_capacity_per_storage_capacity_min:
    description: "Set the lower bound of a `storage`/`supply_plus` technology's energy capacity relative to its storage capacity."
    foreach: [nodes, techs]
    where: "storage_cap AND flow_cap_per_storage_cap_min AND NOT flow_cap_per_storage_cap_equals"
    equations:
      - expression: flow_cap >= storage_cap * flow_cap_per_storage_cap_min

  flow_capacity_per_storage_capacity_max:
    description: "Set the upper bound of a `storage`/`supply_plus` technology's energy capacity relative to its storage capacity."
    foreach: [nodes, techs]
    where: "storage_cap AND flow_cap_per_storage_cap_max AND NOT flow_cap_per_storage_cap_equals"
    equations:
      - expression: flow_cap <= storage_cap * flow_cap_per_storage_cap_max

  flow_capacity_per_storage_capacity_equals:
    description: "Set a fixed relationship between a `storage`/`supply_plus` technology's energy capacity and its storage capacity."
    foreach: [nodes, techs]
    where: "storage_cap AND flow_cap_per_storage_cap_equals"
    equations:
      - expression: flow_cap == storage_cap * flow_cap_per_storage_cap_equals

  source_capacity_equals_flow_capacity:
    description: "Set a `supply_plus` technology's energy capacity to equal its source capacity."
    foreach: [nodes, techs]
    where: source_cap AND source_cap_equals_flow_cap=True
    equations:
      - expression: source_cap == flow_cap

  force_zero_area_use:
    description: "Set a technology's area use to zero if its energy capacity upper bound is zero."
    foreach: [nodes, techs]
    where: "area_use AND flow_cap_max=0"
    equations:
      - expression: area_use == 0

  area_use_per_flow_capacity:
    description: "Set a fixed relationship between a technology's energy capacity and its area use."
    foreach: [nodes, techs]
    where: "area_use AND area_use_per_flow_cap"
    equations:
      - expression: area_use == flow_cap * area_use_per_flow_cap

  area_use_capacity_per_loc:
    description: "Set an upper bound on the total area that all technologies with a area_use can occupy at a given node."
    foreach: [nodes]
    where: "area_use AND available_area"
    equations:
      - expression: sum(area_use, over=techs) <= available_area

  flow_capacity_systemwide:
    description: "Set an upper bound on, or a fixed total of, energy capacity of a technology across all nodes in which the technology exists."
    foreach: [techs]
    where: "(flow_cap_equals_systemwide OR flow_cap_max_systemwide)"
    equations:
      - where: "flow_cap_equals_systemwide"
        expression: sum(flow_cap, over=nodes) == flow_cap_equals_systemwide
      - where: "NOT flow_cap_equals_systemwide"
        expression: sum(flow_cap, over=nodes) <= flow_cap_max_systemwide

  balance_conversion_plus_primary:
    description: "Fix the relationship between total outflow and total inflow of `conversion_plus` technologies for `in` (consumption) and `out` (production) carrier flows."
    foreach: [nodes, techs, timesteps]
    where: "inheritance(conversion_plus) AND carrier_ratios>0"
    equations:
      - expression: reduce_carrier_dim(flow_out / carrier_ratios[carrier_tiers=out], carrier_tier=out) == reduce_carrier_dim(flow_in * carrier_ratios[carrier_tiers=in], carrier_tier=in) * energy_eff

  flow_out_max_conversion_plus:
    description: "Set the upper bound in each timestep of a `conversion_plus` technology's total outflow on its `out` carrier flows."
    foreach: [nodes, techs, timesteps]
    where: "inheritance(conversion_plus) AND NOT cap_method=integer"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) <= timestep_resolution * flow_cap

  flow_out_min_conversion_plus:
    description: "Set the lower bound in each timestep of a `conversion_plus` technology's total outflow on its `out` carrier flows."
    foreach: [nodes, techs, timesteps]
    where: "flow_out_min_relative AND inheritance(conversion_plus) AND NOT cap_method=integer"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) >= timestep_resolution * flow_cap * flow_out_min_relative

  balance_conversion_plus_non_primary:
    description: "Fix the relationship between a `conversion_plus` technology's total `in_2`/`in_3` (consumption) and `out_2`/`out_3` (production) carrier flows and its `in` (consumption) and `out` (production) carrier flows."
    foreach: [nodes, techs, carrier_tiers, timesteps]
    where: "inheritance(conversion_plus) AND [in_2, out_2, in_3, out_3] in carrier_tiers AND carrier_ratios>0"
    equations:
      - expression: $c_1 == $c_2
    sub_expressions:
      c_1:
        - where: "[in_2, in_3] in carrier_tiers"
          expression: reduce_carrier_dim(flow_in / carrier_ratios[carrier_tiers=in], carrier_tier=in)
        - where: "[out_2, out_3] in carrier_tiers"
          expression: reduce_carrier_dim(flow_out / carrier_ratios[carrier_tiers=out], carrier_tier=out)
      c_2:
        - where: "[in_2] in carrier_tiers"
          expression: reduce_carrier_dim(flow_in / carrier_ratios[carrier_tiers=in_2], carrier_tier=in_2)
        - where: "[in_3] in carrier_tiers"
          expression: reduce_carrier_dim(flow_in / carrier_ratios[carrier_tiers=in_3], carrier_tier=in_3)
        - where: "[out_2] in carrier_tiers"
          expression: reduce_carrier_dim(flow_out / carrier_ratios[carrier_tiers=out_2], carrier_tier=out_2)
        - where: "[out_3] in carrier_tiers"
          expression: reduce_carrier_dim(flow_out / carrier_ratios[carrier_tiers=out_3], carrier_tier=out_3)

  conversion_plus_flow_to_zero:
    description: "Set a `conversion_plus` technology's carrier flow to zero if its `carrier_ratio` is zero."
    foreach: [nodes, techs, carriers, timesteps]
    where: "carrier_ratios=0 AND inheritance(conversion_plus)"
    equations:
      - expression: $flow_in_or_out == 0
    sub_expressions:
      flow_in_or_out:
        - where: "[in, in_2, in_3] in carrier_tiers"
          expression: flow_in
        - where: "[out, out_2, out_3] in carrier_tiers"
          expression: flow_out

  balance_conversion:
    description: "Fix the relationship between a `conversion` technology's outflow and consumption."
    foreach: [nodes, techs, timesteps]
    where: "inheritance(conversion)"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) == reduce_carrier_dim(flow_in, carrier_tier=in) * energy_eff

  flow_out_max:
    description: "Set the upper bound of a non-`conversion_plus` technology's outflow."
    foreach: [nodes, techs, carriers, timesteps]
    where: "carrier AND NOT inheritance(conversion_plus) AND NOT cap_method=integer AND allowed_flow_out=True AND [out] in carrier_tiers"
    equations:
      - expression: flow_out <= flow_cap * timestep_resolution * parasitic_eff

  flow_out_min:
    description: "Set the lower bound of a non-`conversion_plus` technology's outflow."
    foreach: [nodes, techs, carriers, timesteps]
    where: "carrier AND flow_out_min_relative AND NOT inheritance(conversion_plus) AND NOT cap_method=integer AND allowed_flow_out=True AND [out] in carrier_tiers"
    equations:
      - expression: flow_out >= flow_cap * timestep_resolution * flow_out_min_relative

  flow_in_max:
    description: "Set the upper bound of a non-`conversion_plus` technology's inflow."
    foreach: [nodes, techs, carriers, timesteps]
    where: "carrier AND (inheritance(transmission) OR inheritance(demand) OR inheritance(storage)) AND (NOT cap_method=integer OR inheritance(demand)) AND allowed_flow_in=True AND [in] in carrier_tiers"
    equations:
      - expression: flow_in <= flow_cap * timestep_resolution

  source_max:
    description: "Set the upper bound of a `supply_plus` technology's source consumption."
    foreach: [nodes, techs, timesteps]
    where: inheritance(supply_plus)
    equations:
      - expression: source_use <= timestep_resolution * source_cap

  storage_max:
    description: "Set the upper bound of the amount of energy a `storage`/`supply_plus` technology can store."
    foreach: [nodes, techs, timesteps]
    where: "storage"
    equations:
      - expression: storage - storage_cap <= 0

  storage_discharge_depth_limit:
    description: "Set the lower bound of the stored energy a `storage`/`supply_plus` technology must keep in reserve at all times."
    foreach: [nodes, techs, timesteps]
    where: "storage AND storage_discharge_depth"
    equations:
      - expression: storage - storage_discharge_depth * storage_cap >= 0

  system_balance:
    description: "Set the global energy balance of the optimisation problem by fixing the total production of a given energy carrier to equal the total consumption of that carrier at every node in every timestep."
    foreach: [nodes, carriers, timesteps]
    equations:
      - expression: "sum(flow_out, over=techs) - sum(flow_in, over=techs) - $carrier_export + $unmet_demand_and_unused_supply == 0"
    sub_expressions:
      carrier_export:
        - where: "any(export_carrier, over=techs)"
          expression: sum(carrier_export, over=techs)
        - where: "NOT any(export_carrier, over=techs)"
          expression: "0"
      unmet_demand_and_unused_supply:
        - where: "run.ensure_feasibility=True"
          expression: unmet_demand + unused_supply
        - where: "NOT run.ensure_feasibility=True"
          expression: "0"

  balance_supply:
    description: "Set the upper bound on, or a fixed total of, a `supply` technology's ability to produce energy based on the quantity of  available source."
    foreach: [nodes, techs, carriers, timesteps]
    where: "source AND inheritance(supply)"
    equations:
      - where: "force_source=True AND energy_eff > 0"
        expression: "flow_out / energy_eff == $available_source"
      - where: "NOT force_source=True AND energy_eff > 0"
        expression: "flow_out / energy_eff <= $available_source"
      - where: "energy_eff = 0"
        expression: "flow_out == 0"
    sub_expressions:
      available_source: &available_source
        - where: "source_unit=energy_per_area"
          expression: "source * source_scale * area_use"
        - where: "source_unit=energy_per_cap"
          expression: "source * source_scale * flow_cap"
        - where: "source_unit=energy"
          expression: "source * source_scale"

  balance_supply_min_use:
    description: "Set the lower bound on, or a fixed amount of, the energy a `supply` technology must consume in each timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "source AND inheritance(supply) AND source_min_use AND energy_eff>0 AND NOT force_source=True"
    equations:
      - expression: "source_min_use <= flow_out / energy_eff"

  balance_demand:
    foreach: [nodes, techs, carriers, timesteps]
    where: "inheritance(demand)"
    equations:
      - where: "force_sink=True"
        expression: "$flow_in == $sink_requirements"
      - where: "NOT force_sink=True"
        expression: "$flow_in <= $sink_requirements"
    sub_expressions:
      flow_in:
        - expression: flow_in * energy_eff
      sink_requirements:
        - where: "sink_unit=energy_per_area"
          expression: "sink * sink_scale * area_use"
        - where: "sink_unit=energy_per_cap"
          expression: "sink * sink_scale * flow_cap"
        - where: "sink_unit=energy"
          expression: "sink * sink_scale"

  balance_supply_plus_no_storage:
    description: "Set the upper bound on, or a fixed total of, a `supply_plus` (without storage) technology's ability to produce energy based on only the quantity of consumed resource."
    foreach: [nodes, techs, carriers, timesteps]
    where: "inheritance(supply_plus) AND NOT include_storage=True"
    equations:
      - expression: source_use * source_eff == $flow_out
    sub_expressions:
      flow_out: &flow_out_with_parasitic
        - where: energy_eff=0 OR parasitic_eff=0
          expression: "0"
        - where: NOT (energy_eff=0 OR parasitic_eff=0)
          expression: flow_out / (energy_eff * parasitic_eff)

  balance_supply_plus_with_storage:
    description: "Set the upper bound on, or a fixed total of, a `supply_plus` (with storage) technology's ability to produce energy based on the quantity of consumed resource and available stored energy."
    foreach: [nodes, techs, carriers, timesteps]
    where: "storage AND inheritance(supply_plus)"
    equations:
      - expression: storage == $storage_previous_step + source_use * source_eff - $flow_out
    sub_expressions:
      flow_out: *flow_out_with_parasitic
      storage_previous_step: &storage_previous_step
        - where: timesteps=get_val_at_index(timesteps=0) AND NOT run.cyclic_storage=True
          expression: storage_initial * storage_cap
        - where: ((timesteps=get_val_at_index(timesteps=0) AND run.cyclic_storage=True) OR NOT timesteps=get_val_at_index(timesteps=0)) AND NOT lookup_cluster_first_timestep=True
          expression: (1 - storage_loss) ** roll(timestep_resolution, timesteps=1) * roll(storage, timesteps=1)
        - where: lookup_cluster_first_timestep=True AND NOT (timesteps=get_val_at_index(timesteps=0) AND NOT run.cyclic_storage=True)
          expression: (1 - storage_loss) ** select_from_lookup_arrays(timestep_resolution, timesteps=lookup_cluster_last_timestep) * select_from_lookup_arrays(storage, timesteps=lookup_cluster_last_timestep)

  source_availability_supply_plus:
    description: "Set the upper bound on, or a fixed total of, a `supply_plus` technology's ability to consume its available energy resource."
    foreach: [nodes, techs, timesteps]
    where: "source_use AND source"
    equations:
      - where: "force_source=True"
        expression: "source_use == $available_source"
      - where: "NOT force_source=True"
        expression: "source_use <= $available_source"
    sub_expressions:
      available_source: *available_source

  balance_storage:
    description: "Fix the quantity of energy stored in a `storage` technology at the end of each timestep based on the net flow of energy charged and discharged and the quantity of energy stored at the start of the timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "inheritance(storage)"
    equations:
      - expression: storage == $storage_previous_step - $flow_out + flow_in * energy_eff
    sub_expressions:
      flow_out:
        - where: energy_eff > 0
          expression: flow_out / energy_eff
        - where: energy_eff = 0
          expression: "0"
      storage_previous_step: *storage_previous_step

  set_storage_initial:
    description: "Fix the relationship between energy stored in a `storage` technology at the start and end of the whole model period."
    foreach: [nodes, techs]
    where: "storage AND storage_initial AND run.cyclic_storage=True"
    equations:
      - expression: storage[timesteps=$final_step] * ((1 - storage_loss) ** timestep_resolution[timesteps=$final_step]) == storage_initial * storage_cap
    slices:
      final_step:
        - expression: get_val_at_index(timesteps=-1)

  balance_transmission:
    description: "Fix the relationship between between energy flowing into and out of a `transmission` link in each timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "inheritance(transmission) AND allowed_flow_out=True"
    equations:
      - expression: "flow_out == select_from_lookup_arrays(flow_in, techs=link_remote_techs, nodes=link_remote_nodes) * energy_eff"

  symmetric_transmission:
    description: "Fix the energy capacity of two `transmission` technologies representing the same link in the system."
    foreach: [nodes, techs]
    where: "inheritance(transmission)"
    equations:
      - expression: flow_cap == select_from_lookup_arrays(flow_cap, techs=link_remote_techs, nodes=link_remote_nodes)

  export_balance:
    description: "Set the lower bound of a technology's outflow to a technology's carrier export, for any technologies that can export energy out of the system."
    foreach: [nodes, techs, carriers, timesteps]
    where: "export_carrier AND export=True"
    equations:
      - expression: flow_out >= carrier_export

  carrier_export_max:
    description: "Set the upper bound of a technology's carrier export, for any technologies that can export energy out of the system."
    foreach: [nodes, techs, carriers, timesteps]
    where: "carrier_export AND export_max"
    equations:
      - where: "cap_method=integer"
        expression: carrier_export <= export_max * operating_units
      - where: "NOT cap_method=integer"
        expression: carrier_export <= export_max

  unit_commitment_milp:
    description: "Set the upper bound of the number of integer units of technology that can exist, for any technology using integer units to define its capacity."
    foreach: [nodes, techs, timesteps]
    where: "cap_method=integer"
    equations:
      - expression: operating_units <= units

  flow_out_max_milp:
    description: "Set the upper bound of a non-`conversion_plus` technology's ability to produce energy, for any technology using integer units to define its capacity."
    foreach: [nodes, techs, carriers, timesteps]
    where: "operating_units AND carrier AND NOT inheritance(conversion_plus) AND allowed_flow_out=True"
    equations:
      - expression: flow_out <= operating_units * timestep_resolution * flow_cap_per_unit * parasitic_eff

  flow_out_max_conversion_plus_milp:
    description: "Set the upper bound of a `conversion_plus` technology's ability to produce energy across all of its `out` energy carriers, if it uses integer units to define its capacity."
    foreach: [nodes, techs, timesteps]
    where: "operating_units AND inheritance(conversion_plus) AND allowed_flow_out=True"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) <= operating_units * timestep_resolution * flow_cap_per_unit

  flow_in_max_milp:
    description: "Set the upper bound of a non-`conversion_plus` technology's ability to consume energy, for any technology using integer units to define its capacity."
    foreach: [nodes, techs, carriers, timesteps]
    where: "operating_units AND NOT inheritance(conversion_plus) AND allowed_flow_in=True"
    equations:
      - expression: flow_in <= operating_units * timestep_resolution * flow_cap_per_unit

  flow_out_min_milp:
    description: "Set the lower bound of a non-`conversion_plus` technology's ability to produce energy, for any technology using integer units to define its capacity."
    foreach: [nodes, techs, carriers, timesteps]
    where: "operating_units AND carrier AND flow_out_min_relative AND NOT inheritance(conversion_plus) AND allowed_flow_out=True"
    equations:
      - expression: flow_out >= operating_units * timestep_resolution * flow_cap_per_unit * flow_out_min_relative

  flow_out_min_conversion_plus_milp:
    description: "Set the lower bound of a `conversion_plus` technology's ability to produce energy across all of its `out` energy carriers, if it uses integer units to define its capacity."
    foreach: [nodes, techs, timesteps]
    where: "operating_units AND flow_out_min_relative AND inheritance(conversion_plus) AND allowed_flow_out=True"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) >= operating_units * timestep_resolution * flow_cap_per_unit * flow_out_min_relative

  storage_capacity_units_milp:
    description: "Fix the storage capacity of any technology using integer units to define its capacity."
    foreach: [nodes, techs]
    where: "operating_units AND storage"
    equations:
      - expression: storage_cap == units * storage_cap_per_unit

  flow_capacity_units_milp:
    description: "Fix the energy capacity of any technology using integer units to define its capacity."
    foreach: [nodes, techs]
    where: "operating_units AND flow_cap_per_unit"
    equations:
      - expression: flow_cap == units * flow_cap_per_unit

  flow_capacity_max_purchase_milp:
    description: "Set the upper bound on, or a fixed total of, a technology's energy capacity, for any technology with binary capacity purchasing."
    foreach: [nodes, techs]
    where: "purchased AND (flow_cap_max OR flow_cap_equals)"
    equations:
      - where: flow_cap_equals
        expression: flow_cap == flow_cap_equals * flow_cap_scale * purchased
      - where: NOT flow_cap_equals
        expression: flow_cap <= flow_cap_max * flow_cap_scale * purchased

  flow_capacity_min_purchase_milp:
    description: "Set the lower bound on a technology's energy capacity, for any technology with binary capacity purchasing."
    foreach: [nodes, techs]
    where: "purchased AND flow_cap_min AND NOT flow_cap_equals"
    equations:
      - expression: flow_cap >= flow_cap_min * flow_cap_scale * purchased

  storage_capacity_max_purchase_milp:
    description: "Set the upper bound on, or a fixed total of, a technology's storage capacity, for any technology with binary capacity purchasing."
    foreach: [nodes, techs]
    where: "purchased AND (storage_cap_max OR storage_cap_equals)"
    equations:
      - where: storage_cap_equals
        expression: storage_cap == storage_cap_equals * purchased
      - where: NOT storage_cap_equals
        expression: storage_cap <= storage_cap_max * purchased

  storage_capacity_min_purchase_milp:
    description: "Set the lower bound on a technology's storage capacity, for any technology with binary capacity purchasing."
    foreach: [nodes, techs]
    where: "purchased AND storage_cap_min AND NOT storage_cap_equals"
    equations:
      - expression: storage_cap >= storage_cap_min * purchased

  unit_capacity_systemwide_milp:
    description: "Set the upper bound on, or a fixed total of, the total number of units of a technology that can be purchased across all nodes where the technology can exist, for any technology using integer units to define its capacity."
    foreach: [techs]
    where: "(purchased OR units) AND (units_max_systemwide OR units_equals_systemwide)"
    equations:
      - where: units_equals_systemwide
        expression: $summed_components == units_equals_systemwide
      - where: NOT units_equals_systemwide
        expression: $summed_components <= units_max_systemwide
    sub_expressions:
      summed_components:
        - where: purchased
          expression: sum(purchased, over=nodes)
        - where: units
          expression: sum(units, over=nodes)

  asynchronous_flow_in_milp:
    description: "Set a technology's ability to have inflow in the same timestep that it has outflow, for any technology using the asynchronous flow binary switch."
    foreach: [nodes, techs, timesteps]
    where: "flow_switch"
    equations:
      - expression: reduce_carrier_dim(flow_in, carrier_tier=in) <= (1 - flow_switch) * bigM

  asynchronous_flow_out_milp:
    description: "Set a technology's ability to have outflow in the same timestep that it has inflow, for any technology using the asynchronous flow binary switch."
    foreach: [nodes, techs, timesteps]
    where: "flow_switch"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) <= flow_switch * bigM

  ramping_up:
    description: "Set the upper bound on a technology's ability to ramp energy production up beyond a certain percentage compared to the previous timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "energy_ramping AND NOT timesteps=get_val_at_index(timesteps=0)"
    equations:
      - expression: $flow - roll($flow, timesteps=1) <= energy_ramping * flow_cap
    sub_expressions:
      flow: &ramping_flow
        - where: "carrier AND allowed_flow_out=True AND NOT allowed_flow_in=True"
          expression: flow_out / timestep_resolution
        - where: "carrier AND allowed_flow_in=True AND NOT allowed_flow_out=True"
          expression: flow_in / timestep_resolution
        - where: "carrier AND allowed_flow_in=True AND allowed_flow_out=True"
          expression: (flow_out - flow_in) / timestep_resolution

  ramping_down:
    description: "Set the upper bound on a technology's ability to ramp energy production down beyond a certain percentage compared to the previous timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "energy_ramping AND NOT timesteps=get_val_at_index(timesteps=0)"
    equations:
      - expression: -1 * energy_ramping * flow_cap <= $flow - roll($flow, timesteps=1)
    sub_expressions:
      flow: *ramping_flow

variables:
  flow_cap:
    description: "A technology's energy capacity, also known as its nominal or nameplate capacity."
    unit: power
    foreach: [nodes, techs]
    bounds:
      min: flow_cap_min
      max: flow_cap_max
      equals: flow_cap_equals
      scale: flow_cap_scale

  flow_out:
    description: "The energy produced by a technology per timestep, also known as the energy discharged (from `storage` technologies) or the energy received (by `transmission` technologies) on a link."
    unit: energy
    foreach: [nodes, techs, carriers, timesteps]
    where: "carrier AND allowed_flow_out=True AND [out, out_2, out_3] in carrier_tiers"
    bounds:
      min: 0
      max: .inf

  flow_in:
    description: "The energy consumed by a technology per timestep, also known as the energy consumed (by `storage` technologies) or the energy sent (by `transmission` technologies) on a link."
    unit: energy
    foreach: [nodes, techs, carriers, timesteps]
    where: "carrier AND allowed_flow_in=True AND [in, in_2, in_3] in carrier_tiers"
    bounds:
      min: 0
      max: .inf

  carrier_export:
    description: "The energy exported outside the system boundaries by a technology per timestep."
    unit: energy
    foreach: [nodes, techs, carriers, timesteps]
    where: "export_carrier AND export=True"
    bounds:
      min: 0
      max: .inf

  area_use:
    description: "The area in space utilised directly (e.g., solar PV panels) or indirectly (e.g., biofuel crops) by a technology."
    unit: area
    foreach: [nodes, techs]
    where: "(area_use_min OR area_use_max OR area_use_equals OR area_use_per_flow_cap OR sink_unit=energy_per_area OR source_unit=energy_per_area)"
    bounds:
      min: area_use_min
      max: area_use_max
      equals: area_use_equals

  source_use:
    description: "The energy consumed from outside the system boundaries by a `supply_plus` technology."
    unit: energy
    foreach: [nodes, techs, timesteps]
    where: "inheritance(supply_plus)"
    bounds:
      min: 0
      max: .inf

  source_cap:
    description: "The upper limit on energy that can be consumed from outside the system boundaries by a `supply_plus` technology in each timestep."
    unit: power
    foreach: [nodes, techs]
    where: "inheritance(supply_plus)"
    bounds:
      min: source_cap_min
      max: source_cap_max
      equals: source_cap_equals

  storage_cap:
    description: "The upper limit on energy that can be stored by a `supply_plus` or `storage` technology in any timestep."
    unit: energy
    foreach: [nodes, techs]
    where: "(inheritance(storage) OR inheritance(supply_plus)) AND include_storage=True"
    bounds:
      min: storage_cap_min
      max: storage_cap_max
      equals: storage_cap_equals

  storage:
    description: "The energy stored by a `supply_plus` or `storage` technology in each timestep."
    unit: energy
    foreach: [nodes, techs, timesteps]
    where: "(inheritance(storage) OR inheritance(supply_plus)) AND include_storage=True"
    bounds:
      min: 0
      max: .inf

  purchased:
    description: "Binary switch defining whether a technology has been purchased or not, for any technology set to require binary capacity purchasing. This is used to set a fixed cost for a technology, irrespective of its installed capacity, on top of which a cost for the quantity of installed capacity can also be applied."
    unit: integer
    foreach: [nodes, techs]
    where: "cap_method=binary"
    domain: integer
    bounds:
      min: 0
      max: 1

  units:
    description: "Integer number of a technology that has been purchased, for any technology set to require inteter capacity purchasing. This is used to allow installation of fixed capacity units of technologies. Since technology capacity is no longer a continuous decision variable, it is possible for these technologies to have a lower bound set on outflow/consumption which will only be enforced in those timesteps that the technology is operating (otherwise, the same lower bound forces the technology to produce/consume that minimum amount of energy in *every* timestep)."
    unit: integer
    foreach: [nodes, techs]
    where: "cap_method=integer"
    domain: integer
    bounds:
      min: units_min
      max: units_max
      equals: units_equals

  operating_units:
    description: "Integer number of a technology that is operating in each timestep, for any technology set to require inteter capacity purchasing."
    unit: integer
    foreach: [nodes, techs, timesteps]
    where: "cap_method=integer"
    domain: integer
    bounds:
      min: 0
      max: .inf

  flow_switch:
    description: "Binary switch to force asynchronous outflow/consumption of a `storage`/`supply_plus`/`transmission` technology. This ensures that a technology with carrier flow efficiencies < 100% cannot produce and consume energy simultaneously to remove unwanted energy from the system."
    unit: integer
    foreach: [nodes, techs, timesteps]
    where: "force_asynchronous_flow=True"
    domain: integer
    bounds:
      min: 0
      max: 1

  unmet_demand:
    description: "Virtual source of energy to ensure model feasibility. This should only be considered a debugging rather than a modelling tool as it may distort the model in other ways due to the large impact it has on the objective function value. When present in a model in which it has been requested, it indicates an inability for technologies in the model to reach a sufficient combined supply capacity to meet demand."
    unit: energy
    foreach: [nodes, carriers, timesteps]
    where: "run.ensure_feasibility=True"
    bounds:
      min: 0
      max: .inf

  unused_supply:
    description: "Virtual sink of energy to ensure model feasibility. This should only be considered a debugging rather than a modelling tool as it may distort the model in other ways due to the large impact it has on the objective function value. In model results, the negation of this variable is combined with `unmet_demand` and presented as only one variable: `unmet_demand`. When present in a model in which it has been requested, it indicates an inability for technologies in the model to reach a sufficient combined consumption capacity to meet required energy production (e.g. from renewables without the possibility of curtailment)."
    unit: energy
    foreach: [nodes, carriers, timesteps]
    where: "run.ensure_feasibility=True"
    bounds:
      min: -.inf
      max: 0

objectives:
  minmax_cost_optimisation:
    description: "Minimise the total cost of installing and operation all technologies in the system. If multiple cost classes are present (e.g., monetary and co2 emissions), the weighted sum of total costs is minimised. Cost class weights can be defined in `run.objective_options.cost_class`."
    equations:
      - expression: sum(sum(cost, over=[nodes, techs]) * objective_cost_class, over=costs) + $unmet_demand
    sub_expressions:
      unmet_demand:
        - where: "run.ensure_feasibility=True"
          expression: sum(sum(unmet_demand - unused_supply, over=[carriers, nodes])  * timestep_weights, over=timesteps) * bigM
        - where: "NOT run.ensure_feasibility=True"
          expression: "0"
    sense: minimise

global_expressions:
  cost_var:
    description: "The operating costs per timestep of a technology"
    unit: cost_per_time
    foreach: [nodes, techs, costs, timesteps]
    where: "cost_export OR cost_om_con OR cost_om_prod"
    equations:
      - expression: timestep_weights * ($cost_export + $cost_om_prod + $cost_om_con)
    sub_expressions:
      cost_export:
        - where: "export_carrier AND cost_export"
          expression: cost_export * sum(carrier_export, over=carriers)
        - where: "NOT cost_export"
          expression: "0"
      cost_om_con:
        - where: "cost_om_con AND inheritance(supply_plus)"
          expression: cost_om_con * source_use
        - where: "cost_om_con AND inheritance(supply) AND energy_eff>0 AND [out] in carrier_tiers"
          expression: cost_om_con * reduce_carrier_dim(flow_out, carrier_tier=out) / energy_eff
        - where: "cost_om_con AND inheritance(conversion_plus)"
          expression: cost_om_con * reduce_primary_carrier_dim(flow_in, carrier_tier=in)
        - where: "cost_om_con AND NOT (inheritance(conversion_plus) OR inheritance(supply_plus) OR inheritance(supply)) AND [in] in carrier_tiers"
          expression: cost_om_con * reduce_carrier_dim(flow_in, carrier_tier=in)
        - where: "NOT cost_om_con"
          expression: "0"
      cost_om_prod:
        - where: "cost_om_prod AND inheritance(conversion_plus)"
          expression: cost_om_prod * reduce_primary_carrier_dim(flow_out, carrier_tier=out)
        - where: "cost_om_prod AND NOT inheritance(conversion_plus)"
          expression: cost_om_prod * reduce_carrier_dim(flow_out, carrier_tier=out)
        - where: "NOT cost_om_prod"
          expression: "0"

  cost_investment:
    description: "The installation costs of a technology, including annualised investment costs and annual maintenance costs."
    unit: cost
    foreach: [nodes, techs, costs]
    where: "(cost_flow_cap OR cost_om_annual OR cost_om_annual_investment_fraction OR cost_purchase OR cost_area_use OR cost_source_cap OR cost_storage_cap)"
    equations:
      - expression: >
          annualisation_weight * (
            cost_depreciation_rate * (
                $cost_flow_cap + $cost_storage_cap + $cost_source_cap
                + $cost_area_use + $cost_of_purchase
              ) * ($multiplier + cost_om_annual_investment_fraction)
              + cost_om_annual * flow_cap
          )
    sub_expressions:
      multiplier:
        - where: "inheritance(transmission)"
          expression: "0.5"
        - where: "NOT inheritance(transmission)"
          expression: "1"
      cost_flow_cap:
        - where: "cost_flow_cap"
          expression: cost_flow_cap * flow_cap
        - where: "NOT cost_flow_cap"
          expression: "0"
      cost_storage_cap:
        - where: "cost_storage_cap AND storage_cap"
          expression: cost_storage_cap * storage_cap
        - where: "NOT (cost_storage_cap AND storage_cap)"
          expression: "0"
      cost_source_cap:
        - where: "cost_source_cap AND source_cap"
          expression: cost_source_cap * source_cap
        - where: "NOT (cost_source_cap AND source_cap)"
          expression: "0"
      cost_area_use:
        - where: "cost_area_use AND area_use"
          expression: "cost_area_use * area_use"
        - where: "NOT (cost_area_use AND area_use)"
          expression: "0"
      cost_of_purchase:
        - where: "cost_purchase AND purchased"
          expression: "cost_purchase * purchased"
        - where: "cost_purchase AND units"
          expression: "cost_purchase * units"
        - where: "NOT (cost_purchase AND (purchased OR units))"
          expression: "0"

  cost:
    description: "The total annualised costs of a technology, including installation and operation costs."
    unit: cost
    foreach: [nodes, techs, costs]
    where: "cost_investment OR cost_var"
    equations:
      - expression: $cost_investment + $cost_var_sum
    sub_expressions:
      cost_investment:
        - where: "cost_investment"
          expression: cost_investment
        - where: "NOT cost_investment"
          expression: "0"
      cost_var_sum:
        - where: "cost_var"
          expression: sum(cost_var, over=timesteps)
        - where: "NOT cost_var"
          expression: "0"
