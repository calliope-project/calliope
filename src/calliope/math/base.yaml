constraints:
  flow_capacity_per_storage_capacity_min:
    description: "Set the lower bound of a `storage`/`supply_plus` technology's flow capacity relative to its storage capacity."
    foreach: [nodes, techs]
    where: "storage_cap AND flow_cap_per_storage_cap_min"
    equations:
      - expression: flow_cap >= storage_cap * flow_cap_per_storage_cap_min

  flow_capacity_per_storage_capacity_max:
    description: "Set the upper bound of a `storage`/`supply_plus` technology's flow capacity relative to its storage capacity."
    foreach: [nodes, techs]
    where: "storage_cap AND flow_cap_per_storage_cap_max"
    equations:
      - expression: flow_cap <= storage_cap * flow_cap_per_storage_cap_max

  source_capacity_equals_flow_capacity:
    description: "Set a `supply_plus` technology's flow capacity to equal its source capacity."
    foreach: [nodes, techs]
    where: source_cap AND source_cap_equals_flow_cap=True
    equations:
      - expression: source_cap == flow_cap

  force_zero_area_use:
    description: "Set a technology's area use to zero if its flow capacity upper bound is zero."
    foreach: [nodes, techs]
    where: "area_use AND flow_cap_max=0"
    equations:
      - expression: area_use == 0

  area_use_per_flow_capacity:
    description: "Set a fixed relationship between a technology's flow capacity and its area use."
    foreach: [nodes, techs]
    where: "area_use AND area_use_per_flow_cap"
    equations:
      - expression: area_use == flow_cap * area_use_per_flow_cap

  area_use_capacity_per_loc:
    description: "Set an upper bound on the total area that all technologies with a area_use can occupy at a given node."
    foreach: [nodes]
    where: "area_use AND available_area"
    equations:
      - expression: sum(area_use, over=techs) <= available_area

  flow_capacity_systemwide_max:
    description: "Set an upper bound on flow capacity of a technology across all nodes in which the technology exists."
    foreach: [techs]
    where: "flow_cap_max_systemwide"
    equations:
      - expression: sum(flow_cap, over=nodes) <= flow_cap_max_systemwide

  flow_capacity_systemwide_min:
    description: "Set a lower bound on flow capacity of a technology across all nodes in which the technology exists."
    foreach: [techs]
    where: "flow_cap_min_systemwide"
    equations:
      - expression: sum(flow_cap, over=nodes) >= flow_cap_min_systemwide

  balance_conversion_plus_primary:
    description: "Fix the relationship between total outflow and total inflow of `conversion_plus` technologies for `in` (consumption) and `out` (production) carrier flows."
    foreach: [nodes, techs, timesteps]
    where: "inheritance(conversion_plus) AND carrier_ratios>0"
    equations:
      - expression: reduce_carrier_dim(flow_out / carrier_ratios[carrier_tiers=out], carrier_tier=out) == reduce_carrier_dim(flow_in * carrier_ratios[carrier_tiers=in], carrier_tier=in) * flow_eff

  flow_out_max_conversion_plus:
    description: "Set the upper bound in each timestep of a `conversion_plus` technology's total outflow on its `out` carrier flows."
    foreach: [nodes, techs, timesteps]
    where: "inheritance(conversion_plus) AND NOT operating_units"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) <= timestep_resolution * flow_cap

  flow_out_min_conversion_plus:
    description: "Set the lower bound in each timestep of a `conversion_plus` technology's total outflow on its `out` carrier flows."
    foreach: [nodes, techs, timesteps]
    where: "flow_out_min_relative AND inheritance(conversion_plus) AND NOT operating_units"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) >= timestep_resolution * flow_cap * flow_out_min_relative

  balance_conversion_plus_non_primary:
    description: "Fix the relationship between a `conversion_plus` technology's total `in_2`/`in_3` (consumption) and `out_2`/`out_3` (production) carrier flows and its `in` (consumption) and `out` (production) carrier flows."
    foreach: [nodes, techs, carrier_tiers, timesteps]
    where: "inheritance(conversion_plus) AND [in_2, out_2, in_3, out_3] in carrier_tiers AND carrier_ratios>0"
    equations:
      - expression: $c_1 == $c_2
    sub_expressions:
      c_1:
        - where: "[in_2, in_3] in carrier_tiers"
          expression: reduce_carrier_dim(flow_in / carrier_ratios[carrier_tiers=in], carrier_tier=in)
        - where: "[out_2, out_3] in carrier_tiers"
          expression: reduce_carrier_dim(flow_out / carrier_ratios[carrier_tiers=out], carrier_tier=out)
      c_2:
        - where: "[in_2] in carrier_tiers"
          expression: reduce_carrier_dim(flow_in / carrier_ratios[carrier_tiers=in_2], carrier_tier=in_2)
        - where: "[in_3] in carrier_tiers"
          expression: reduce_carrier_dim(flow_in / carrier_ratios[carrier_tiers=in_3], carrier_tier=in_3)
        - where: "[out_2] in carrier_tiers"
          expression: reduce_carrier_dim(flow_out / carrier_ratios[carrier_tiers=out_2], carrier_tier=out_2)
        - where: "[out_3] in carrier_tiers"
          expression: reduce_carrier_dim(flow_out / carrier_ratios[carrier_tiers=out_3], carrier_tier=out_3)

  conversion_plus_flow_to_zero:
    description: "Set a `conversion_plus` technology's carrier flow to zero if its `carrier_ratio` is zero."
    foreach: [nodes, techs, carriers, timesteps]
    where: "carrier_ratios=0 AND inheritance(conversion_plus)"
    equations:
      - expression: $flow_in_or_out == 0
    sub_expressions:
      flow_in_or_out:
        - where: "[in, in_2, in_3] in carrier_tiers"
          expression: flow_in
        - where: "[out, out_2, out_3] in carrier_tiers"
          expression: flow_out

  balance_conversion:
    description: "Fix the relationship between a `conversion` technology's outflow and consumption."
    foreach: [nodes, techs, timesteps]
    where: "inheritance(conversion)"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) == reduce_carrier_dim(flow_in, carrier_tier=in) * flow_eff

  flow_out_max:
    description: "Set the upper bound of a non-`conversion_plus` technology's outflow."
    foreach: [nodes, techs, carriers, timesteps]
    where: "NOT inheritance(conversion_plus) AND NOT operating_units AND allowed_flow_out=True AND [out] in carrier_tiers"
    equations:
      - expression: flow_out <= flow_cap * timestep_resolution * parasitic_eff

  flow_out_min:
    description: "Set the lower bound of a non-`conversion_plus` technology's outflow."
    foreach: [nodes, techs, carriers, timesteps]
    where: "flow_out_min_relative AND NOT inheritance(conversion_plus) AND NOT operating_units AND allowed_flow_out=True AND [out] in carrier_tiers"
    equations:
      - expression: flow_out >= flow_cap * timestep_resolution * flow_out_min_relative

  flow_in_max:
    description: "Set the upper bound of a non-`conversion_plus` technology's inflow."
    foreach: [nodes, techs, carriers, timesteps]
    where: "(inheritance(transmission) OR inheritance(demand) OR inheritance(storage)) AND (NOT operating_units OR inheritance(demand)) AND allowed_flow_in=True AND [in] in carrier_tiers"
    equations:
      - expression: flow_in <= flow_cap * timestep_resolution

  source_use_max:
    description: "Set the upper bound of a `supply_plus` technology's source consumption."
    foreach: [nodes, techs, timesteps]
    where: inheritance(supply_plus)
    equations:
      - expression: source_use <= timestep_resolution * source_cap

  storage_max:
    description: "Set the upper bound of the amount of carrier a `storage`/`supply_plus` technology can store."
    foreach: [nodes, techs, timesteps]
    where: "storage"
    equations:
      - expression: storage - storage_cap <= 0

  storage_discharge_depth_limit:
    description: "Set the lower bound of the stored carrier a `storage`/`supply_plus` technology must keep in reserve at all times."
    foreach: [nodes, techs, timesteps]
    where: "storage AND storage_discharge_depth"
    equations:
      - expression: storage - storage_discharge_depth * storage_cap >= 0

  system_balance:
    description: "Set the global carrier balance of the optimisation problem by fixing the total production of a given carrier to equal the total consumption of that carrier at every node in every timestep."
    foreach: [nodes, carriers, timesteps]
    equations:
      - expression: "sum(flow_out, over=techs) - sum(flow_in, over=techs) - $flow_export + $unmet_demand_and_unused_supply == 0"
    sub_expressions:
      flow_export:
        - where: "any(export_carrier, over=techs)"
          expression: sum(flow_export, over=techs)
        - where: "NOT any(export_carrier, over=techs)"
          expression: "0"
      unmet_demand_and_unused_supply:
        - where: "config.ensure_feasibility=True"
          expression: unmet_demand + unused_supply
        - where: "NOT config.ensure_feasibility=True"
          expression: "0"

  balance_supply:
    description: "Set the upper bound on, or a fixed total of, a `supply` technology's ability to produce a carrier based on the quantity of  available source."
    foreach: [nodes, techs, carriers, timesteps]
    where: "(source_equals OR source_max) AND inheritance(supply)"
    equations:
      - where: "source_equals AND flow_eff > 0"
        expression: "flow_out / flow_eff == source_equals * $source_scaler"
      - where: "(NOT source_equals) AND sink_max AND flow_eff > 0"
        expression: "flow_out / flow_eff <= source_max * $source_scaler"
      - where: "flow_eff = 0"
        expression: "flow_out == 0"
    sub_expressions:
      source_scaler: &source_scaler
        - where: "source_unit=per_area"
          expression: "area_use"
        - where: "source_unit=per_cap"
          expression: "flow_cap"
        - where: "source_unit=absolute"
          expression: "1"

  balance_supply_min_use:
    description: "Set the lower bound on the quantity of its source a `supply` technology must use in each timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "source_min AND NOT source_equals AND inheritance(supply) AND flow_eff>0"
    equations:
      - expression: "flow_out / flow_eff >= source_min * $source_scaler"
    sub_expressions:
      source_scaler: *source_scaler

  balance_demand:
    foreach: [nodes, techs, carriers, timesteps]
    where: "inheritance(demand)"
    equations:
      - where: "sink_equals"
        expression: "$flow_in == sink_equals * $sink_scaler"
      - where: "NOT sink_equals AND sink_max"
        expression: "$flow_in <= sink_max * $sink_scaler"
    sub_expressions:
      flow_in:
        - expression: flow_in * flow_eff
      sink_scaler: &sink_scaler
        - where: "sink_unit=per_area"
          expression: "area_use"
        - where: "sink_unit=per_cap"
          expression: "flow_cap"
        - where: "sink_unit=absolute"
          expression: "1"

  balance_demand_min_use:
    description: "Set the lower bound on the quantity of flow a `demand` technology must dump to its sink in each timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "sink_min AND NOT source_equals AND inheritance(supply) AND flow_eff>0"
    equations:
      - expression: "sink_min * $sink_scaler <= flow_in * flow_eff"
    sub_expressions:
      sink_scaler: *sink_scaler

  balance_supply_plus_no_storage:
    description: "Set the upper bound on, or a fixed total of, a `supply_plus` (without storage) technology's ability to produce flow based on only the quantity of consumed resource."
    foreach: [nodes, techs, carriers, timesteps]
    where: "inheritance(supply_plus) AND NOT include_storage=True"
    equations:
      - expression: source_use * source_eff == $flow_out
    sub_expressions:
      flow_out: &flow_out_with_parasitic
        - where: flow_eff=0 OR parasitic_eff=0
          expression: "0"
        - where: NOT (flow_eff=0 OR parasitic_eff=0)
          expression: flow_out / (flow_eff * parasitic_eff)

  balance_supply_plus_with_storage:
    description: "Set the upper bound on, or a fixed total of, a `supply_plus` (with storage) technology's ability to produce flow based on the quantity of consumed resource and available stored carrier."
    foreach: [nodes, techs, carriers, timesteps]
    where: "storage AND inheritance(supply_plus)"
    equations:
      - expression: storage == $storage_previous_step + source_use * source_eff - $flow_out
    sub_expressions:
      flow_out: *flow_out_with_parasitic
      storage_previous_step: &storage_previous_step
        - where: timesteps=get_val_at_index(timesteps=0) AND NOT config.cyclic_storage=True
          expression: storage_initial * storage_cap
        - where: ((timesteps=get_val_at_index(timesteps=0) AND config.cyclic_storage=True) OR NOT timesteps=get_val_at_index(timesteps=0)) AND NOT lookup_cluster_first_timestep=True
          expression: (1 - storage_loss) ** roll(timestep_resolution, timesteps=1) * roll(storage, timesteps=1)
        - where: lookup_cluster_first_timestep=True AND NOT (timesteps=get_val_at_index(timesteps=0) AND NOT config.cyclic_storage=True)
          expression: (1 - storage_loss) ** select_from_lookup_arrays(timestep_resolution, timesteps=lookup_cluster_last_timestep) * select_from_lookup_arrays(storage, timesteps=lookup_cluster_last_timestep)

  source_availability_supply_plus:
    description: "Set the upper bound on, or a fixed total of, a `supply_plus` technology's ability to consume its available resource."
    foreach: [nodes, techs, timesteps]
    where: "source_use AND (source_equals OR source_max)"
    equations:
      - where: "source_equals"
        expression: "source_use == source_equals * $source_scaler"
      - where: "NOT source_equals AND source_max"
        expression: "source_use <= source_max * $source_scaler"
    sub_expressions:
      source_scaler: *source_scaler

  balance_storage:
    description: "Fix the quantity of carrier stored in a `storage` technology at the end of each timestep based on the net flow of carrier charged and discharged and the quantity of carrier stored at the start of the timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "inheritance(storage)"
    equations:
      - expression: storage == $storage_previous_step - $flow_out + flow_in * flow_eff
    sub_expressions:
      flow_out:
        - where: flow_eff > 0
          expression: flow_out / flow_eff
        - where: flow_eff = 0
          expression: "0"
      storage_previous_step: *storage_previous_step

  set_storage_initial:
    description: "Fix the relationship between carrier stored in a `storage` technology at the start and end of the whole model period."
    foreach: [nodes, techs]
    where: "storage AND storage_initial AND config.cyclic_storage=True"
    equations:
      - expression: storage[timesteps=$final_step] * ((1 - storage_loss) ** timestep_resolution[timesteps=$final_step]) == storage_initial * storage_cap
    slices:
      final_step:
        - expression: get_val_at_index(timesteps=-1)

  balance_transmission:
    description: "Fix the relationship between between carrier flowing into and out of a `transmission` link in each timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "inheritance(transmission) AND allowed_flow_out=True"
    equations:
      - expression: "flow_out == select_from_lookup_arrays(flow_in, techs=link_remote_techs, nodes=link_remote_nodes) * flow_eff"

  symmetric_transmission:
    description: "Fix the flow capacity of two `transmission` technologies representing the same link in the system."
    foreach: [nodes, techs]
    where: "inheritance(transmission)"
    equations:
      - expression: flow_cap == select_from_lookup_arrays(flow_cap, techs=link_remote_techs, nodes=link_remote_nodes)

  export_balance:
    description: "Set the lower bound of a technology's outflow to a technology's carrier export, for any technologies that can export carriers out of the system."
    foreach: [nodes, techs, carriers, timesteps]
    where: "export_carrier AND export=True"
    equations:
      - expression: flow_out >= flow_export

  flow_export_max:
    description: "Set the upper bound of a technology's carrier export, for any technologies that can export carriers out of the system."
    foreach: [nodes, techs, carriers, timesteps]
    where: "flow_export AND export_max"
    equations:
      - where: "operating_units"
        expression: flow_export <= export_max * operating_units
      - where: "NOT operating_units"
        expression: flow_export <= export_max

  unit_commitment_milp:
    description: "Set the upper bound of the number of integer units of technology that can exist, for any technology using integer units to define its capacity."
    foreach: [nodes, techs, timesteps]
    where: "operating_units"
    equations:
      - expression: operating_units <= units

  flow_out_max_milp:
    description: "Set the upper bound of a non-`conversion_plus` technology's ability to produce carriers, for any technology using integer units to define its capacity."
    foreach: [nodes, techs, carriers, timesteps]
    where: "operating_units AND NOT inheritance(conversion_plus) AND allowed_flow_out=True"
    equations:
      - expression: flow_out <= operating_units * timestep_resolution * flow_cap_per_unit * parasitic_eff

  flow_out_max_conversion_plus_milp:
    description: "Set the upper bound of a `conversion_plus` technology's ability to outflow across all of its `out` carriers, if it uses integer units to define its capacity."
    foreach: [nodes, techs, timesteps]
    where: "operating_units AND inheritance(conversion_plus) AND allowed_flow_out=True"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) <= operating_units * timestep_resolution * flow_cap_per_unit

  flow_in_max_milp:
    description: "Set the upper bound of a non-`conversion_plus` technology's ability to consume carriers, for any technology using integer units to define its capacity."
    foreach: [nodes, techs, carriers, timesteps]
    where: "operating_units AND NOT inheritance(conversion_plus) AND allowed_flow_in=True"
    equations:
      - expression: flow_in <= operating_units * timestep_resolution * flow_cap_per_unit

  flow_out_min_milp:
    description: "Set the lower bound of a non-`conversion_plus` technology's ability to produce carriers, for any technology using integer units to define its capacity."
    foreach: [nodes, techs, carriers, timesteps]
    where: "operating_units AND flow_out_min_relative AND NOT inheritance(conversion_plus) AND allowed_flow_out=True"
    equations:
      - expression: flow_out >= operating_units * timestep_resolution * flow_cap_per_unit * flow_out_min_relative

  flow_out_min_conversion_plus_milp:
    description: "Set the lower bound of a `conversion_plus` technology's ability to outflow across all of its `out` carriers, if it uses integer units to define its capacity."
    foreach: [nodes, techs, timesteps]
    where: "operating_units AND flow_out_min_relative AND inheritance(conversion_plus) AND allowed_flow_out=True"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) >= operating_units * timestep_resolution * flow_cap_per_unit * flow_out_min_relative

  storage_capacity_units_milp:
    description: "Fix the storage capacity of any technology using integer units to define its capacity."
    foreach: [nodes, techs]
    where: "operating_units AND storage"
    equations:
      - expression: storage_cap == units * storage_cap_per_unit

  flow_capacity_units_milp:
    description: "Fix the flow capacity of any technology using integer units to define its capacity."
    foreach: [nodes, techs]
    where: "operating_units AND flow_cap_per_unit"
    equations:
      - expression: flow_cap == units * flow_cap_per_unit

  flow_capacity_max_purchase_milp:
    description: "Set the upper bound on, or a fixed total of, a technology's flow capacity, for any technology with binary capacity purchasing."
    foreach: [nodes, techs]
    where: "purchased AND flow_cap_max"
    equations:
      - expression: flow_cap <= flow_cap_max * purchased

  flow_capacity_min_purchase_milp:
    description: "Set the lower bound on a technology's flow capacity, for any technology with binary capacity purchasing."
    foreach: [nodes, techs]
    where: "purchased AND flow_cap_min AND NOT flow_cap_equals"
    equations:
      - expression: flow_cap >= flow_cap_min * purchased

  storage_capacity_max_purchase_milp:
    description: "Set the upper bound on, or a fixed total of, a technology's storage capacity, for any technology with binary capacity purchasing."
    foreach: [nodes, techs]
    where: "purchased AND storage_cap_max"
    equations:
      - expression: storage_cap <= storage_cap_max * purchased

  storage_capacity_min_purchase_milp:
    description: "Set the lower bound on a technology's storage capacity, for any technology with binary capacity purchasing."
    foreach: [nodes, techs]
    where: "purchased AND storage_cap_min AND NOT storage_cap_equals"
    equations:
      - expression: storage_cap >= storage_cap_min * purchased

  unit_capacity_max_systemwide_milp:
    description: "Set the upper bound on the total number of units of a technology that can be purchased across all nodes where the technology can exist, for any technology using integer units to define its capacity."
    foreach: [techs]
    where: "(purchased OR units) AND units_max_systemwide"
    equations:
      - expression: $summed_components <= units_max_systemwide
    sub_expressions: &unit_capacity_systemwide_milp_sub_exprs
      summed_components:
        - where: purchased
          expression: sum(purchased, over=nodes)
        - where: units
          expression: sum(units, over=nodes)

  unit_capacity_min_systemwide_milp:
    description: "Set the lower bound on the total number of units of a technology that can be purchased across all nodes where the technology can exist, for any technology using integer units to define its capacity."
    foreach: [techs]
    where: "(purchased OR units) AND units_min_systemwide"
    equations:
      - expression: $summed_components >= units_min_systemwide
    sub_expressions: *unit_capacity_systemwide_milp_sub_exprs

  async_flow_in_milp:
    description: "Set a technology's ability to have inflow in the same timestep that it has outflow, for any technology using the asynchronous flow binary switch."
    foreach: [nodes, techs, timesteps]
    where: "async_flow_switch"
    equations:
      - expression: reduce_carrier_dim(flow_in, carrier_tier=in) <= (1 - async_flow_switch) * bigM

  async_flow_out_milp:
    description: "Set a technology's ability to have outflow in the same timestep that it has inflow, for any technology using the asynchronous flow binary switch."
    foreach: [nodes, techs, timesteps]
    where: "async_flow_switch"
    equations:
      - expression: reduce_carrier_dim(flow_out, carrier_tier=out) <= async_flow_switch * bigM

  ramping_up:
    description: "Set the upper bound on a technology's ability to ramp outflow up beyond a certain percentage compared to the previous timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "flow_ramping AND NOT timesteps=get_val_at_index(timesteps=0)"
    equations:
      - expression: $flow - roll($flow, timesteps=1) <= flow_ramping * flow_cap
    sub_expressions:
      flow: &ramping_flow
        - where: "allowed_flow_out=True AND NOT allowed_flow_in=True"
          expression: flow_out / timestep_resolution
        - where: "allowed_flow_in=True AND NOT allowed_flow_out=True"
          expression: flow_in / timestep_resolution
        - where: "allowed_flow_in=True AND allowed_flow_out=True"
          expression: (flow_out - flow_in) / timestep_resolution

  ramping_down:
    description: "Set the upper bound on a technology's ability to ramp outflow down beyond a certain percentage compared to the previous timestep."
    foreach: [nodes, techs, carriers, timesteps]
    where: "flow_ramping AND NOT timesteps=get_val_at_index(timesteps=0)"
    equations:
      - expression: -1 * flow_ramping * flow_cap <= $flow - roll($flow, timesteps=1)
    sub_expressions:
      flow: *ramping_flow

variables:
  flow_cap:
    description: "A technology's flow capacity, also known as its nominal or nameplate capacity."
    unit: power
    foreach: [nodes, techs]
    bounds:
      min: flow_cap_min
      max: flow_cap_max

  flow_out:
    description: "The outflow of a technology per timestep, also known as the flow discharged (from `storage` technologies) or the flow received (by `transmission` technologies) on a link."
    unit: energy
    foreach: [nodes, techs, carriers, timesteps]
    where: "allowed_flow_out=True AND [out, out_2, out_3] in carrier_tiers"
    bounds:
      min: 0
      max: .inf

  flow_in:
    description: "The inflow to a technology per timestep, also known as the flow consumed (by `storage` technologies) or the flow sent (by `transmission` technologies) on a link."
    unit: energy
    foreach: [nodes, techs, carriers, timesteps]
    where: "allowed_flow_in=True AND [in, in_2, in_3] in carrier_tiers"
    bounds:
      min: 0
      max: .inf

  flow_export:
    description: "The flow of a carrier exported outside the system boundaries by a technology per timestep."
    unit: energy
    foreach: [nodes, techs, carriers, timesteps]
    where: "export_carrier AND export=True"
    bounds:
      min: 0
      max: .inf

  area_use:
    description: "The area in space utilised directly (e.g., solar PV panels) or indirectly (e.g., biofuel crops) by a technology."
    unit: area
    foreach: [nodes, techs]
    where: "(area_use_min OR area_use_max OR area_use_per_flow_cap OR sink_unit=per_area OR source_unit=per_area)"
    bounds:
      min: area_use_min
      max: area_use_max

  source_use:
    description: "The carrier flow consumed from outside the system boundaries by a `supply_plus` technology."
    unit: energy
    foreach: [nodes, techs, timesteps]
    where: "inheritance(supply_plus)"
    bounds:
      min: 0
      max: .inf

  source_cap:
    description: "The upper limit on a flow that can be consumed from outside the system boundaries by a `supply_plus` technology in each timestep."
    unit: power
    foreach: [nodes, techs]
    where: "inheritance(supply_plus)"
    bounds:
      min: source_cap_min
      max: source_cap_max

  storage_cap:
    description: "The upper limit on a carrier that can be stored by a `supply_plus` or `storage` technology in any timestep."
    unit: energy
    foreach: [nodes, techs]
    where: "(inheritance(storage) OR inheritance(supply_plus)) AND include_storage=True"
    bounds:
      min: storage_cap_min
      max: storage_cap_max

  storage:
    description: "The carrier stored by a `supply_plus` or `storage` technology in each timestep."
    unit: energy
    foreach: [nodes, techs, timesteps]
    where: "(inheritance(storage) OR inheritance(supply_plus)) AND include_storage=True"
    bounds:
      min: 0
      max: .inf

  purchased:
    description: "Binary switch defining whether a technology has been purchased or not, for any technology set to require binary capacity purchasing. This is used to set a fixed cost for a technology, irrespective of its installed capacity, on top of which a cost for the quantity of installed capacity can also be applied."
    unit: integer
    foreach: [nodes, techs]
    where: "cap_method=binary"
    domain: integer
    bounds:
      min: 0
      max: 1

  units:
    description: "Integer number of a technology that has been purchased, for any technology set to require inteter capacity purchasing. This is used to allow installation of fixed capacity units of technologies. Since technology capacity is no longer a continuous decision variable, it is possible for these technologies to have a lower bound set on outflow/consumption which will only be enforced in those timesteps that the technology is operating (otherwise, the same lower bound forces the technology to produce/consume that minimum amount of carrier in *every* timestep)."
    unit: integer
    foreach: [nodes, techs]
    where: "cap_method=integer"
    domain: integer
    bounds:
      min: units_min
      max: units_max

  operating_units:
    description: "Integer number of a technology that is operating in each timestep, for any technology set to require inteter capacity purchasing."
    unit: integer
    foreach: [nodes, techs, timesteps]
    where: "cap_method=integer"
    domain: integer
    bounds:
      min: 0
      max: .inf

  async_flow_switch:
    description: "Binary switch to force asynchronous outflow/consumption of a `storage`/`supply_plus`/`transmission` technology. This ensures that a technology with carrier flow efficiencies < 100% cannot produce and consume a flow simultaneously to remove unwanted carrier from the system."
    unit: integer
    foreach: [nodes, techs, timesteps]
    where: "force_async_flow=True"
    domain: integer
    bounds:
      min: 0
      max: 1

  unmet_demand:
    description: "Virtual source of carrier flow to ensure model feasibility. This should only be considered a debugging rather than a modelling tool as it may distort the model in other ways due to the large impact it has on the objective function value. When present in a model in which it has been requested, it indicates an inability for technologies in the model to reach a sufficient combined supply capacity to meet demand."
    unit: energy
    foreach: [nodes, carriers, timesteps]
    where: "config.ensure_feasibility=True"
    bounds:
      min: 0
      max: .inf

  unused_supply:
    description: "Virtual sink of carrier flow to ensure model feasibility. This should only be considered a debugging rather than a modelling tool as it may distort the model in other ways due to the large impact it has on the objective function value. In model results, the negation of this variable is combined with `unmet_demand` and presented as only one variable: `unmet_demand`. When present in a model in which it has been requested, it indicates an inability for technologies in the model to reach a sufficient combined consumption capacity to meet required outflow (e.g. from renewables without the possibility of curtailment)."
    unit: energy
    foreach: [nodes, carriers, timesteps]
    where: "config.ensure_feasibility=True"
    bounds:
      min: -.inf
      max: 0

objectives:
  minmax_cost_optimisation:
    description: "Minimise the total cost of installing and operation all technologies in the system. If multiple cost classes are present (e.g., monetary and co2 emissions), the weighted sum of total costs is minimised. Cost class weights can be defined in the top-level parameter `objective_cost_class`."
    equations:
      - where: "any(cost, over=[nodes, techs, costs])"
        expression: sum(sum(cost, over=[nodes, techs]) * objective_cost_class, over=costs) + $unmet_demand
      - where: "NOT any(cost, over=[nodes, techs, costs])"
        expression: $unmet_demand
    sub_expressions:
      unmet_demand:
        - where: "config.ensure_feasibility=True"
          expression: sum(sum(unmet_demand - unused_supply, over=[carriers, nodes])  * timestep_weights, over=timesteps) * bigM
        - where: "NOT config.ensure_feasibility=True"
          expression: "0"
    sense: minimise

global_expressions:
  cost_var:
    description: "The operating costs per timestep of a technology"
    unit: cost_per_time
    foreach: [nodes, techs, costs, timesteps]
    where: "cost_export OR cost_om_con OR cost_om_prod"
    equations:
      - expression: timestep_weights * ($cost_export + $cost_om_prod + $cost_om_con)
    sub_expressions:
      cost_export:
        - where: "export_carrier AND cost_export"
          expression: cost_export * sum(flow_export, over=carriers)
        - where: "NOT cost_export"
          expression: "0"
      cost_om_con:
        - where: "cost_om_con AND inheritance(supply_plus)"
          expression: cost_om_con * source_use
        - where: "cost_om_con AND inheritance(supply) AND flow_eff>0 AND [out] in carrier_tiers"
          expression: cost_om_con * reduce_carrier_dim(flow_out, carrier_tier=out) / flow_eff
        - where: "cost_om_con AND inheritance(conversion_plus)"
          expression: cost_om_con * reduce_primary_carrier_dim(flow_in, carrier_tier=in)
        - where: "cost_om_con AND NOT (inheritance(conversion_plus) OR inheritance(supply_plus) OR inheritance(supply)) AND [in] in carrier_tiers"
          expression: cost_om_con * reduce_carrier_dim(flow_in, carrier_tier=in)
        - where: "NOT cost_om_con"
          expression: "0"
      cost_om_prod:
        - where: "cost_om_prod AND inheritance(conversion_plus)"
          expression: cost_om_prod * reduce_primary_carrier_dim(flow_out, carrier_tier=out)
        - where: "cost_om_prod AND NOT inheritance(conversion_plus)"
          expression: cost_om_prod * reduce_carrier_dim(flow_out, carrier_tier=out)
        - where: "NOT cost_om_prod"
          expression: "0"

  cost_investment:
    description: "The installation costs of a technology, including annualised investment costs and annual maintenance costs."
    unit: cost
    foreach: [nodes, techs, costs]
    where: "(cost_flow_cap OR cost_om_annual OR cost_om_annual_investment_fraction OR cost_purchase OR cost_area_use OR cost_source_cap OR cost_storage_cap)"
    equations:
      - expression: >
          annualisation_weight * (
            cost_depreciation_rate * (
                $cost_flow_cap + $cost_storage_cap + $cost_source_cap
                + $cost_area_use + $cost_of_purchase
              ) * ($multiplier + cost_om_annual_investment_fraction)
              + cost_om_annual * flow_cap
          )
    sub_expressions:
      multiplier:
        - where: "inheritance(transmission)"
          expression: "0.5"
        - where: "NOT inheritance(transmission)"
          expression: "1"
      cost_flow_cap:
        - where: "cost_flow_cap"
          expression: cost_flow_cap * flow_cap
        - where: "NOT cost_flow_cap"
          expression: "0"
      cost_storage_cap:
        - where: "cost_storage_cap AND storage_cap"
          expression: cost_storage_cap * storage_cap
        - where: "NOT (cost_storage_cap AND storage_cap)"
          expression: "0"
      cost_source_cap:
        - where: "cost_source_cap AND source_cap"
          expression: cost_source_cap * source_cap
        - where: "NOT (cost_source_cap AND source_cap)"
          expression: "0"
      cost_area_use:
        - where: "cost_area_use AND area_use"
          expression: "cost_area_use * area_use"
        - where: "NOT (cost_area_use AND area_use)"
          expression: "0"
      cost_of_purchase:
        - where: "cost_purchase AND purchased"
          expression: "cost_purchase * purchased"
        - where: "cost_purchase AND units"
          expression: "cost_purchase * units"
        - where: "NOT (cost_purchase AND (purchased OR units))"
          expression: "0"

  cost:
    description: "The total annualised costs of a technology, including installation and operation costs."
    unit: cost
    foreach: [nodes, techs, costs]
    where: "cost_investment OR cost_var"
    equations:
      - expression: $cost_investment + $cost_var_sum
    sub_expressions:
      cost_investment:
        - where: "cost_investment"
          expression: cost_investment
        - where: "NOT cost_investment"
          expression: "0"
      cost_var_sum:
        - where: "cost_var"
          expression: sum(cost_var, over=timesteps)
        - where: "NOT cost_var"
          expression: "0"
