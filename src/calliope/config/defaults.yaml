#
# NB Parts of this file are automatically parsed and extracted for the configuration reference documentation.
# See `doc/user/configuration_reference.rst` and `doc/generate_tables.py`, which populates
# the `doc/user/includes` directory
#

##
# Model-wide default settings
##

config:
  init:
    name: null # Model name
    calliope_version: null # Calliope framework version this model is intended for
    time_subset: null # (Optional) Subset of timesteps as a two-element list giving the range, e.g. ['2005-01-01', '2005-01-05'], or a single string, e.g. '2005-01'
    time_resample: null # (Optional) setting to adjust time resolution, e.g. "2H" for 2-hourly
    time_cluster: null # (Optional) setting to cluster the timeseries, must be a path to a file where each date is linked to a representative date that also exists in the timeseries.
    time_data_path: "." # Path to time series data. If relative, it will be relative to the base model definition file.
    time_format: "ISO8601" # Timestamp format of all time series data when read from file. "ISO8601" means "YYYY-mm-dd HH:MM:SS".
    custom_math: [] # List of references to files which contain custom mathematical formulations. If referring to an in-built Calliope custom math file (see documentation for available files), do not append the reference with ".yaml". If referring to your own custom math file, ensure the file type is given as a suffix (".yaml" or ".yml"). Relative paths will be assumed to be relative to the `config` file given when creating a calliope Model (`calliope.Model(config)`)
  build:
    backend: pyomo  # Module with which to build the optimisation problem
    cyclic_storage: true  # whether or not to link storage levels in the last model timestep with the first model timestep. `inter_cluster_storage` custom math must be included if using time clustering and setting this to True.
    ensure_feasibility: false  # whether to include decision variables in the model which will meet unmet demand or consume unused supply in the model so that the optimisation solves successfully. This should only be used as a debugging option (as any unmet demand/unused supply is a sign of improper model formulation).
    mode: plan  # Mode in which to run the optimisation. Options: [plan, operate, spores]
    objective: min_cost_optimisation # Name of internal objective function to use, currently only min/max cost-based optimisation is available
  solve:
    operate_window: null  # Operate mode rolling `window`
    operate_horizon: null  # Operate mode rolling `horizon` (â‰¥ `window`)
    operate_use_cap_results: false  # If the model already contains `plan` mode results, use those optimal capacities as input parameters to the `operate` mode run.
    spores_number: 3  # SPORES mode number of iterations after the initial base run.
    spores_score_cost_class: spores_score  # SPORES mode cost class to vary between iterations after the initial base run.
    spores_slack_cost_group: null  # SPORES mode cost class to keep below the given `slack` (usually "monetary").
    spores_save_per_spore: false  # Whether or not to save the result of each SPORES mode run between iterations. If False, will consolidate all iterations into one dataset after completion of N iterations (defined by `spores_number`) and save that one dataset.
    spores_save_per_spore_path: null  # If saving per spore, the path to save to.
    spores_skip_cost_op: false  # If the model already contains `plan` mode results, use those as the initial base run results and start with SPORES iterations immediately.
    save_logs: null  # If given, should be a path to a directory in which to save optimisation logs.
    solver_io: null  # Some solvers have different interfaces that perform differently. For instance, setting `solver_io="python"` when using the solver `gurobi` tends to reduce the time to send the optimisation problem to the solver.
    solver_options: null  # Any solver options, as key-value pairs, to pass to the chosen solver
    solver: cbc  # Solver to use. Any solvers that have Pyomo interfaces can be used. Refer to the Pyomo documentation for the latest list.
    zero_threshold: 1e-10  # On postprocessing the optimisation results, values smaller than this threshold will be considered as optimisation artefacts and will be set to zero.

parameters:
  # BigM is a large value used to define certain optimisation problems.
  # See https://en.wikipedia.org/wiki/Big_M_method for more information.
  # This value should be larger than the largest values that any decision variables can take,
  # but should not be **too** large (i.e., do not set it greater than 3 orders of magnitude above the numeric range of the model).
  # if too large, numerical problems may arise in the optimisation.
  bigM: 1e9
  objective_cost_weights: # Weightings for cost classes to apply in the objective function.
    data: 1
    index: [monetary]
    dims: costs

##
# Base technology groups
##

tech_groups:
  conversion:
    required_constraints: []
    allowed_constraints:
      [
        "flow_cap_max",
        "flow_cap_max_systemwide",
        "flow_cap_min",
        "flow_cap_min_systemwide",
        "flow_out_min_relative",
        "flow_cap_per_unit",
        "flow_in_eff",
        "flow_out_eff",
        "flow_out_parasitic_eff",
        "flow_ramping",
        "export_max",
        "export_carrier",
        "lifetime",
        "units_min_systemwide",
        "units_max",
        "units_max_systemwide",
        "units_min",
      ]
    allowed_costs:
      [
        "depreciation_rate",
        "flow_cap",
        "export",
        "interest_rate",
        "om_annual",
        "om_annual_investment_fraction",
        "flow_in",
        "flow_out",
        "purchase",
      ]
    allowed_switches: [cap_method, export, allowed_flow_in, allowed_flow_out]
    essentials:
      parent: null
    switches:
      cap_method: linear
      export: false
      allowed_flow_in: true
      allowed_flow_out: true

  conversion_plus:
    required_constraints: []
    allowed_constraints:
      [
        "carrier_ratios",
        "flow_cap_min_systemwide",
        "flow_cap_max",
        "flow_cap_max_systemwide",
        "flow_cap_min",
        "flow_out_min_relative",
        "flow_cap_per_unit",
        "flow_in_eff",
        "flow_out_eff",
        "flow_ramping",
        "export_max",
        "export_carrier",
        "lifetime",
        "units_min_systemwide",
        "units_max",
        "units_max_systemwide",
        "units_min",
      ]
    allowed_costs:
      [
        "depreciation_rate",
        "flow_cap",
        "export",
        "interest_rate",
        "om_annual",
        "om_annual_investment_fraction",
        "flow_in",
        "flow_out",
        "purchase",
      ]
    allowed_switches: [cap_method, export, allowed_flow_in, allowed_flow_out]
    essentials:
      parent: null
    switches:
      cap_method: linear
      export: false
      allowed_flow_in: true
      allowed_flow_out: true
  demand:
    required_constraints: []
    allowed_constraints: ["sink_min", "sink_max", "sink_equals", "sink_unit"]
    allowed_costs: [flow_in]
    allowed_switches: [sink_unit, allowed_flow_in, allowed_flow_out]
    essentials:
      parent: null
    switches:
      sink_unit: absolute
      allowed_flow_in: true
      allowed_flow_out: false
  storage:
    required_constraints: []
    allowed_constraints:
      [
        "flow_cap_per_storage_cap_min",
        "flow_cap_per_storage_cap_max",
        "flow_cap_min_systemwide",
        "flow_cap_max",
        "flow_cap_max_systemwide",
        "flow_cap_min",
        "flow_out_min_relative",
        "flow_cap_per_unit",
        "flow_in_eff",
        "flow_out_eff",
        "flow_out_parasitic_eff",
        "flow_ramping",
        "export_max",
        "export_carrier",
        "force_async_flow",
        "lifetime",
        "storage_cap_max",
        "storage_cap_min",
        "storage_cap_per_unit",
        "storage_initial",
        "storage_loss",
        "storage_time_max",
        "storage_discharge_depth",
        "units_min_systemwide",
        "units_max",
        "units_max_systemwide",
        "units_min",
      ]
    allowed_costs:
      [
        "depreciation_rate",
        "flow_cap",
        "export",
        "interest_rate",
        "om_annual",
        "om_annual_investment_fraction",
        "flow_out",
        "purchase",
        "storage_cap",
      ]
    allowed_switches:
      [cap_method, include_storage, export, allowed_flow_in, allowed_flow_out]
    essentials:
      parent: null
    switches:
      include_storage: True
      cap_method: linear
      export: false
      allowed_flow_in: true
      allowed_flow_out: true
  supply:
    required_constraints: []
    allowed_constraints:
      [
        "flow_cap_min_systemwide",
        "flow_cap_max",
        "flow_cap_max_systemwide",
        "flow_cap_min",
        "flow_out_min_relative",
        "flow_cap_per_unit",
        "flow_in_eff",
        "flow_out_eff",
        "flow_out_parasitic_eff",
        "flow_ramping",
        "export_max",
        "export_carrier",
        "lifetime",
        "area_use_max",
        "area_use_min",
        "area_use_per_flow_cap",
        "source_min",
        "source_max",
        "source_equals",
        "units_min_systemwide",
        "units_max",
        "units_max_systemwide",
        "units_min",
      ]
    allowed_costs:
      [
        "depreciation_rate",
        "flow_cap",
        "export",
        "interest_rate",
        "om_annual",
        "om_annual_investment_fraction",
        "flow_in",
        "flow_out",
        "purchase",
        "area_use",
      ]
    allowed_switches:
      [cap_method, source_unit, export, allowed_flow_in, allowed_flow_out]
    essentials:
      parent: null
    switches:
      source_unit: absolute
      cap_method: linear
      export: false
      allowed_flow_out: true
      allowed_flow_in: false

  supply_plus:
    required_constraints: []
    allowed_constraints:
      [
        "flow_cap_per_storage_cap_min",
        "flow_cap_per_storage_cap_max",
        "flow_cap_min_systemwide",
        "flow_cap_max",
        "flow_cap_max_systemwide",
        "flow_cap_min",
        "flow_out_min_relative",
        "flow_cap_per_unit",
        "flow_in_eff",
        "flow_out_eff",
        "flow_out_parasitic_eff",
        "flow_ramping",
        "export_max",
        "export_carrier",
        "lifetime",
        "area_use_max",
        "area_use_min",
        "area_use_per_flow_cap",
        "source_cap_max",
        "source_cap_min",
        "source_eff",
        "source_min",
        "source_max",
        "source_equals",
        "storage_cap_max",
        "storage_cap_min",
        "storage_cap_per_unit",
        "storage_initial",
        "storage_loss",
        "units_min_systemwide",
        "units_max",
        "units_max_systemwide",
        "units_min",
      ]
    allowed_costs:
      [
        "depreciation_rate",
        "flow_cap",
        "export",
        "interest_rate",
        "om_annual",
        "om_annual_investment_fraction",
        "flow_in",
        "flow_out",
        "purchase",
        "area_use",
        "source_cap",
        "storage_cap",
      ]
    allowed_switches:
      [
        cap_method,
        include_storage,
        source_unit,
        source_cap_equals_flow_cap,
        export,
        allowed_flow_in,
        allowed_flow_out,
      ]
    essentials:
      parent: null
    switches:
      source_unit: absolute
      cap_method: linear
      include_storage: False
      force_async_flow: false
      source_cap_equals_flow_cap: false
      export: false
      allowed_flow_out: true
      allowed_flow_in: False

  transmission:
    required_constraints: []
    allowed_constraints:
      [
        "flow_cap_min",
        "flow_cap_max",
        "flow_cap_per_unit",
        "flow_in_eff",
        "flow_out_eff",
        "flow_out_parasitic_eff",
        "flow_in_eff_per_distance",
        "flow_out_eff_per_distance",
        "force_async_flow",
        "lifetime",
        "one_way",
      ]
    allowed_costs:
      [
        "depreciation_rate",
        "flow_cap",
        "flow_cap_per_distance",
        "interest_rate",
        "om_annual",
        "om_annual_investment_fraction",
        "flow_out",
        "purchase",
        "purchase_per_distance",
      ]
    allowed_switches: [cap_method, one_way, allowed_flow_in, allowed_flow_out]
    essentials:
      parent: null
    switches:
      cap_method: linear
      one_way: false
      allowed_flow_in: true
      allowed_flow_out: true

##
# Default technology
##
techs:
  default_tech:
    essentials:
      carrier_in: false # Defaults to false, allows technologies to define primary carrier(s) to consume
      carrier_in_2: false # Defaults to false, allows technologies to define secondary carrier(s) to consume
      carrier_in_3: false # Defaults to false, allows technologies to define tertiary carrier(s) to consume
      carrier_out: false # Defaults to false, allows conversion technologies to define primary carrier(s) to produce
      carrier_out_2: false # Defaults to false, allows conversion technologies to define secondary carrier(s) to produce
      carrier_out_3: false # Defaults to false, allows conversion technologies to define tertiary carrier(s) to produce
      color: false # Color to use when plotting results. If not defined, a random one will be chosen
      name: "Default technology" # Name of tech, used for plotting and analysis
      parent: null # Parent tech_group. Must always be defined
      primary_carrier_in: false # Selects the primary input carrier to associate with costs & constraints (if multiple primary input carriers are assigned)
      primary_carrier_out: false # Selects the primary output carrier to associate with costs & constraints (if multiple primary output carriers are assigned)
    switches:
      cap_method: linear # name: capacity method switch, one of 'linear' (LP model), 'binary' (uses purchase decision variable), or 'integer' (uses units and operating _units decision variables)
      include_storage: False # name: boolean storage method swtich. Used for supply plus technologies to define a storage between source consumption and outflow
      force_async_flow: false # name: Force asynchronous out/inflow Â¦ unit: boolean Â¦ If True, flow_out and flow_in cannot both occur in the same timestep
      sink_unit: absolute # name: Sink unit Â¦ unit: N/A Â¦ Sets the unit of ``Sink`` to either ``absolute`` (e.g. kWh), ``per_area`` (e.g. kWh/m2), or ``per_cap`` (e.g. kWh/kW). ``per_area`` uses the ``area_use`` decision variable to scale the sink while ``per_cap`` uses the ``flow_cap`` decision variable.
      source_unit: absolute # name: Source unit Â¦ unit: N/A Â¦ Sets the unit of ``Source`` to either ``absolute`` (e.g. kWh), ``per_area`` (e.g. kWh/m2), or ``per_cap`` (e.g. kWh/kW). ``per_area`` uses the ``area_use`` decision variable to scale the source while ``per_cap`` uses the ``flow_cap`` decision variable.
      source_cap_equals_flow_cap: false # name: Source capacity equals flow capacity Â¦ unit: boolean Â¦ If true, ``source_cap`` is forced to equal ``flow_cap``
      one_way: false # name: One way Â¦ unit: boolean Â¦ Forces a transmission technology to only move flow in one direction on the link, in this case from `default_node_from` to `default_node_to`
      allowed_flow_in: false # name: Technology inflow Â¦ unit: boolean Â¦ Allow this technology to consume flow from the carrier (static boolean, or from file as timeseries).
      allowed_flow_out: false # name: Technology outflow Â¦ unit: boolean Â¦ Allow this technology to supply flow to the carrier (static boolean, or from file as timeseries).
      export: false
    constraints:
      carrier_ratios: 1 # name: Carrier ratios Â¦ unit: fraction Â¦ Ratio of summed output of carriers in ['out_2', 'out_3'] / ['in_2', 'in_3'] to the summed output of carriers in 'out' / 'in'. given in a nested dictionary.
      flow_cap_per_storage_cap_min: 0 # name: Minimum flow capacity per storage capacity Â¦ unit: hour :sup:`-1` Â¦ ratio of minimum charge/discharge (kW) for a given storage capacity (kWh).
      flow_cap_per_storage_cap_max: .inf # name: Maximum flow capacity per storage capacity Â¦ unit: hour :sup:`-1` Â¦ ratio of maximum charge/discharge (kW) for a given storage capacity (kWh).
      flow_cap_per_storage_cap_equals: null # name: Tie flow capacity to storage capacity Â¦ unit: hour :sup:`-1` Â¦
      flow_cap_max: .inf # name: Maximum installed flow capacity Â¦ unit: kW Â¦ Limits decision variables ``flow_out``/``flow_in`` to a maximum/minimum.
      flow_cap_max_systemwide: .inf # name: System-wide maximum installed flow capacity Â¦ unit: kW Â¦ Limits the sum to a maximum/minimum, for a particular technology, of the decision variables ``flow_out``/``flow_in`` over all nodes.
      flow_cap_min: 0 # name: Minimum installed flow capacity Â¦ unit: kW Â¦ Limits decision variables ``flow_out``/``flow_in`` to a minimum/maximum.
      flow_cap_min_systemwide: 0 # name: System-wide specific installed flow capacity Â¦ unit: kW Â¦ sets the lower bound of the sum across all nodes of the decision variable `flow_cap` for a particular technology.
      flow_out_min_relative: 0 # name: Minimum outflow Â¦ unit: fraction Â¦ Set to a value between 0 and 1 to force minimum outflow as a fraction of the technology maximum flow capacity. If non-zero and technology is not defined by ``units``, this will force the technology to operate above its minimum value at every timestep.
      flow_cap_per_unit: null # name: Flow capacity per purchased unit Â¦ unit: kW/unit Â¦ Set the capacity of each integer unit of a technology purchased
      flow_in_eff: 1.0 # name: Inflow efficiency Â¦ unit: fraction Â¦ conversion efficiency (static, or from file as timeseries), from ``source``/``flow_in`` (tech dependent) into the technology.
      flow_out_eff: 1.0 # name: Outflow efficiency Â¦ unit: fraction Â¦ conversion efficiency (static, or from file as timeseries), from ``source``/``flow_in`` (tech dependent) into the technology.
      flow_in_eff_per_distance: 1.0 # name: Inflow (i.e., export from node) efficiency per distance for transmission links Â¦ unit: fraction/distance Â¦ Set as value between 1 (no loss) and 0 (all lost).
      flow_out_eff_per_distance: 1.0 # name: outflow (i.e., import from node) efficiency per distance for transmission links Â¦ unit: fraction/distance Â¦ Set as value between 1 (no loss) and 0 (all lost).
      flow_ramping: 1 # name: Ramping rate Â¦ unit: fraction / hour Â¦ Set to ``false`` to disable ramping constraints, otherwise limit maximum outflow to a fraction of maximum capacity, which increases by that fraction at each timestep.
      export_max: .inf # name: Maximum allowed export Â¦ unit: kW Â¦ Maximum allowed export of produced carrier for a technology.
      export_carrier: null # name: Export carrier Â¦ unit: N/A Â¦ Name of carrier to be exported. Must be an output carrier of the technology
      lifetime: null # name: Technology lifetime Â¦ unit: years Â¦ Must be defined if fixed capital costs are defined. A reasonable value for many technologies is around 20-25 years.
      flow_out_parasitic_eff: 1.0 # name: Plant parasitic efficiency Â¦ unit: fraction Â¦ Additional losses as flow gets transferred from the plant to the carrier (static, or from file as timeseries), e.g. due to plant parasitic consumption
      sink_min: 0 # name: Minimum bound on sink to remove a carrier from the system (e.g., electricity demand, transport distance) Â¦ unit: kWh | kWh/m\ :sup:`2` | kWh/kW Â¦ Minimum sink use (static, or from file as timeseries). Unit dictated by ``source_unit``.
      sink_max: .inf # name: Maximum bound on sink to remove a carrier from the system (e.g., electricity demand, transport distance) Â¦ unit: kWh | kWh/m\ :sup:`2` | kWh/kW Â¦ Maximum sink use (static, or from file as timeseries). Unit dictated by ``source_unit``.
      sink_equals: null # name: Required amount removal of a carrier from the system through a sink (e.g., electricity demand, transport distance) Â¦ unit: kWh | kWh/m\ :sup:`2` | kWh/kW Â¦ Required sink (static, or from file as timeseries). Unit dictated by ``source_unit``.
      source_min: 0 # name: Minimum bound on source to add to the system (e.g., biofuel, coal, rainfall, wind flow) Â¦ unit: kWh | kWh/m\ :sup:`2` | kWh/kW Â¦ Minimum available source (static, or from file as timeseries). Unit dictated by ``source_unit``.
      source_max: .inf # name: Maximum bound on source to add to the system (e.g., biofuel, coal, rainfall, wind flow) Â¦ unit: kWh | kWh/m\ :sup:`2` | kWh/kW Â¦ Maximum available source (static, or from file as timeseries). Unit dictated by ``source_unit``.
      source_equals: null # name: Exact amount of source to add to the system (e.g., biofuel, coal, rainfall, wind flow) Â¦ unit: kWh | kWh/m\ :sup:`2` | kWh/kW Â¦ Required source (static, or from file as timeseries). Unit dictated by ``source_unit``.
      area_use_max: .inf # name: Maximum usable area Â¦ unit: m\ :sup:`2` Â¦ If set to a finite value, restricts the usable area of the technology to this value.
      area_use_min: 0 # name: Minimum usable area Â¦ unit: m\ :sup:`2` Â¦
      area_use_per_flow_cap: null # name: Area use per flow capacity Â¦ unit: m\ :sup: `2`/kW Â¦ If set, forces ``area_use`` to follow ``flow_cap`` with the given numerical ratio (e.g. setting to 1.5 means that ``area_use == 1.5 * flow_cap``)
      source_cap_max: .inf # name: Maximum installed source consumption capacity Â¦ unit: kW Â¦
      source_cap_min: 0 # name: Minimum installed source consumption capacity Â¦ unit: kW Â¦
      source_eff: 1.0 # name: Efficiency of converting a source into usable resource Â¦ unit: fraction Â¦ Efficiency (static, or from file as timeseries) in capturing source before it reaches storage (if storage is present) or conversion to carrier.
      storage_cap_max: .inf # name: Maximum storage capacity Â¦ unit: kWh Â¦ If not defined, ``flow_cap_max`` * ``flow_cap_per_storage_cap_max`` will be used as the capacity.
      storage_cap_min: 0 # name: Minimum storage capacity Â¦ unit: kWh Â¦
      storage_cap_per_unit: null # name: Storage capacity per purchased unit Â¦ unit: kWh/unit Â¦ Set the storage capacity of each integer unit of a technology purchased.
      storage_discharge_depth: 0 # name: Storage depth of discharge Â¦ unit: fraction Â¦ Defines the minimum level of storage state of charge, as a fraction of total storage capacity
      storage_initial: 0 # name: Initial storage level Â¦ unit: fraction Â¦ Set stored flow in device at the first timestep, as a fraction of total storage capacity
      storage_loss: 0 # name: Storage loss rate Â¦ unit: fraction/hour Â¦ rate of storage loss per hour (static, or from file as timeseries), used to calculate lost stored flow as ``(1 - storage_loss)^hours_per_timestep``
      units_min_systemwide: 0 # name: System-wide minimum installed flow capacity Â¦ unit: integer Â¦ sets the lower bound of the sum across all nodes of the decision variable `units`for a particular technology.
      units_max_systemwide: .inf # name: System-wide minimum installed flow capacity Â¦ unit: integer Â¦ sets the upper bound of the sum across all nodes of the decision variable `units`for a particular technology.
      units_min: 0 # name: Minimum number of purchased units Â¦ unit: integer Â¦ Turns the model from LP to MILP.
      units_max: .inf # name: Maximum number of purchased units Â¦ unit: integer Â¦ Turns the model from LP to MILP.
    costs:
      default_cost: # These costs are used for any value not defined for a given cost class
        flow_cap: 0 # name: Cost of flow capacity Â¦ unit: kW :sub:`gross` :sup:`-1` Â¦
        flow_cap_per_distance: 0 # name: Cost of flow capacity, per unit distance Â¦ unit: kW :sub:`gross` :sup:`-1` / distance Â¦ Applied to transmission links only
        export: 0 # name: Carrier export cost Â¦ unit: kWh :sup:`-1` Â¦ Usually used in the negative sense, as a subsidy.
        interest_rate: 0 # name: Interest rate Â¦ unit: fraction Â¦ Used when computing levelized costs
        om_annual: 0 # name: Yearly O&M costs Â¦ unit: kW :sub:`flow_cap` :sup:`-1` Â¦
        om_annual_investment_fraction: 0 # name: Fractional yearly O&M costs Â¦ unit: fraction / total investment Â¦
        flow_in: 0 # name: Carrier consumption cost Â¦ unit: kWh :sup:`-1` Â¦ Applied to carrier consumption of a technology
        flow_out: 0 # name: outflow cost Â¦ unit: kWh :sup:`-1` Â¦ Applied to outflow of a technology
        purchase: 0 # name: Purchase cost Â¦ unit: unit :sup:`-1` Â¦ Will be applied to either the binary variable `purchased` or the integer variable ``units``
        purchase_per_distance: 0 # name: Purchase cost per unit distance for transmission techs Â¦ unit: unit :sup:`-1` / distance Â¦  Will be applied to either the binary variable `purchased` or the integer variable ``units``
        area_use: 0 # name: Cost of area use Â¦ unit: m\ :sup:`-2` Â¦
        source_cap: 0 # name: Cost of source flow capacity Â¦ unit: kW :sup:`-1` Â¦
        storage_cap: 0 # name: Cost of storage capacity Â¦ unit: kWh :sup:`-1` Â¦
        depreciation_rate: 1 # name: Depreciation rate for annualisation of investment costs Â¦ unit: fraction Â¦
    active: true

nodes:
  default_node:
    transmission_node: false # true only if no techs are defined (including complete omission of the `techs` key). Automatically added during processing if not defined by user.
    coordinates: {} # The node's x-y coordinates for distance calculations and plotting: {lat: ..., lon: ...} or {x: ..., y: ...}
    available_area: .inf # This node's available land area (required if constraining technology deployment by area).
    techs: null # A list of technologies, optionally with node-specific settings overriding the technology's global settings.
    active: true

links:
  default_node_from,default_node_to:
    techs:
      default_tech:
        distance: null # Used for per_distance constraints, but automatically inferred from coordinates of nodes in a link if not given directly

    active: true
